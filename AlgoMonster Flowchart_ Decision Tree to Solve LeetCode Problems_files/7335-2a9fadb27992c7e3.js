(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7335],{5454:function(e,t,n){"use strict";var o=n(85893),i=n(9268),s=n(42481),r=n(26671),a=n(27326),l=n(85522),c=n.n(l);r.O$.hljs.background="transparent",r.O$.hljs.padding="0",a.default.hljs.background="transparent",a.default.hljs.padding="0";t.Z=function(e){var t=e.className,n=e.inline,l=e.language,m=e.children,h=e.value,d=e.darkMode,p=e.showLineNumbers,u=void 0===p||p,b=/language-(\w+)/.exec(t||"");return n?(0,o.jsx)("code",{children:m}):(0,o.jsx)(s.Z,{showLineNumbers:u,children:m?String(m).replace(/\n$/,""):h,language:l?i.ih[l].hljsLang:null!==b?b[1]:void 0,style:d?a.default:r.O$,className:c().codeBlock})}},92270:function(e,t,n){"use strict";n.d(t,{Z:function(){return _}});var o=n(26042),i=n(69396),s=n(828),r=n(29815),a=n(85893),l=n(69071),c=n(67294),m=n(17754),h={width:"200px",height:"200px",backgroundColor:"#ffcc00",transform:"rotate(45deg)",display:"flex",justifyContent:"center",alignItems:"center",borderRadius:5},d={transform:"rotate(-45deg)",textAlign:"center",width:"70%",wordWrap:"break-word",fontSize:24,fontWeight:700},p=function(e){var t=e.data,n=(0,m.m0)().darkModeFlag,s=(0,i.Z)((0,o.Z)({},h),{border:t.isSelected?"2px solid #00ff00":"none",color:n?"#000":"#ffcc00"});return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(l.HH,{type:"target",position:l.Ly.Top}),(0,a.jsx)("div",{style:s,children:(0,a.jsx)("div",{style:(0,i.Z)((0,o.Z)({},d),{color:"black"}),children:t.label})}),(0,a.jsx)(l.HH,{type:"source",position:l.Ly.Bottom})]})},u={background:"#98A2EE",padding:15,borderRadius:5,borderWidth:"2px",borderStyle:"solid",borderColor:"transparent",fontSize:24,fontWeight:700},b=function(e){var t=e.data,n=(0,m.m0)().darkModeFlag,s=(0,i.Z)((0,o.Z)({},u),{borderColor:t.isSelected?"#00ff00":"transparent",color:n?"#000":"#fff"});return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(l.HH,{type:"target",position:l.Ly.Top}),(0,a.jsx)("div",{style:s,children:(0,a.jsx)("div",{children:t.label})}),(0,a.jsx)(l.HH,{type:"source",position:l.Ly.Bottom})]})},g=function(e){var t=e.id,n=e.sourceX,r=e.sourceY,c=e.targetX,h=e.targetY,d=e.sourcePosition,p=e.targetPosition,u=e.data,b=e.style,g=(0,m.m0)().darkModeFlag,f=(0,s.Z)((0,l.OQ)({sourceX:n,sourceY:r,sourcePosition:d,targetX:c,targetY:h,targetPosition:p}),3),y=f[0],w=f[1],v=f[2];return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("path",{id:t,className:"react-flow__edge-path",d:y,style:(0,i.Z)((0,o.Z)({},b),{strokeWidth:"5px"})}),(0,a.jsx)(l.XQ,{children:(0,a.jsx)("div",{style:{position:"absolute",transform:"translate(-50%, -50%) translate(".concat(w,"px,").concat(v,"px)"),background:g?"#fff":"#000",padding:5,fontSize:24,fontWeight:700,color:g?"#000":"#fff"},className:"nodrag nopan",children:u.label})})]})},f=(n(54722),{custom:g}),y={diamond:p,leaf:b},w=[{id:"graph",data:{label:"Is it a graph?"},position:{x:100,y:0},type:"diamond"},{id:"tree",data:{label:"Is it a tree?"},position:{x:500,y:100},type:"diamond"},{id:"tree-dfs",data:{label:"DFS"},position:{x:900,y:200},type:"leaf"},{id:"directed-graph",data:{label:"Is problem related to directed acyclic graphs?"},position:{x:500,y:500},type:"diamond"},{id:"directed-graph-topo",data:{label:"Topological Sort"},position:{x:900,y:600},type:"leaf"},{id:"shortest-path",data:{label:"Is the problem related to shortest paths?"},position:{x:500,y:900},type:"diamond"},{id:"shortest-path-weighted",data:{label:"Is the graph Weighted?"},position:{x:900,y:1e3},type:"diamond"},{id:"shortest-path-dijkstra",data:{label:"Dijkstra's Algorithm"},position:{x:1300,y:1100},type:"leaf"},{id:"shortest-path-bfs",data:{label:"BFS"},position:{x:1300,y:1300},type:"leaf"},{id:"connectivity",data:{label:"Does the problem involve connectivity"},position:{x:500,y:1300},type:"diamond"},{id:"connectivity-dsu",data:{label:"Disjoint Set Union"},position:{x:900,y:1400},type:"leaf"},{id:"graph-smallcontraints",data:{label:"Does the problem have small constraints?"},position:{x:500,y:1700},type:"diamond"},{id:"graph-smallcontraints-dfs",data:{label:"DFS/backtracking"},position:{x:900,y:1800},type:"leaf"},{id:"graph-smallcontraints-bfs",data:{label:"BFS"},position:{x:900,y:2e3},type:"leaf"},{id:"kth-smallest",data:{label:"Need to solve for kth smallest/largest?"},position:{x:100,y:2e3},type:"diamond"},{id:"kth-smallest-heap",data:{label:"Heap / Sortings"},position:{x:500,y:2100},type:"leaf"},{id:"linked-list",data:{label:"Involves Linked Lists?"},position:{x:100,y:2400},type:"diamond"},{id:"linked-list-twopointers",data:{label:"Two pointers"},position:{x:500,y:2500},type:"leaf"},{id:"small-constraints",data:{label:"Small constraint bounds?"},position:{x:100,y:2800},type:"diamond"},{id:"small-constraints-efficiency",data:{label:"Is brute force fast enough?"},position:{x:500,y:2900},type:"diamond"},{id:"small-constraints-bruteforce/backtracking",data:{label:"Brute force / Backtracking"},position:{x:900,y:3e3},type:"leaf"},{id:"small-constraints-dp",data:{label:"Dynamic Programming"},position:{x:900,y:3150},type:"leaf"},{id:"subarrays",data:{label:"About subarrays or substrings?"},position:{x:100,y:3500},type:"diamond"},{id:"sums",data:{label:"Deals with sums or additive"},position:{x:100,y:3150},type:"diamond"},{id:"subarrays-prefixsums",data:{label:"Prefix Sums"},position:{x:500,y:3500},type:"leaf"},{id:"subarrays-twopointers",data:{label:"Sliding Window"},position:{x:500,y:3800},type:"leaf"},{id:"max/min",data:{label:"Calculating max/min of something?"},position:{x:100,y:3900},type:"diamond"},{id:"max/min-monotonic",data:{label:"Monotonic condition?"},position:{x:500,y:4e3},type:"diamond"},{id:"max/min-subproblem",data:{label:"Can be split into sub-problems?"},position:{x:500,y:4400},type:"diamond"},{id:"max/min-greedyhuh",data:{label:"Greedily calculate answer?"},position:{x:500,y:4800},type:"diamond"},{id:"max/min-binarysearch",data:{label:"Binary Search"},position:{x:900,y:4100},type:"leaf"},{id:"max/min-dp",data:{label:"Dynamic Programming"},position:{x:900,y:4500},type:"leaf"},{id:"max/min-greedy",data:{label:"Greedy Algorithms"},position:{x:900,y:4900},type:"leaf"},{id:"counting",data:{label:"Asking for number of ways?"},position:{x:100,y:4800},type:"diamond"},{id:"counting-efficiency",data:{label:"Is brute force fast enough?"},position:{x:500,y:5100},type:"diamond"},{id:"counting-bruteforce/backtracking",data:{label:"Brute Force / Backtracking"},position:{x:900,y:5150},type:"leaf"},{id:"counting-dp",data:{label:"Dynamic Programming"},position:{x:900,y:5300},type:"leaf"},{id:"sequence-count",data:{label:"Multiple sequences?"},position:{x:100,y:5300},type:"diamond"},{id:"sequence-count-monotonic",data:{label:"Monotonic conditions?"},position:{x:500,y:5400},type:"diamond"},{id:"sequence-count-subproblems",data:{label:"Can split into sub-problems?"},position:{x:500,y:5800},type:"diamond"},{id:"sequence-count-twopointers",data:{label:"Two pointers"},position:{x:900,y:5500},type:"leaf"},{id:"sequence-count-dp",data:{label:"Dynamic Programming"},position:{x:900,y:5900},type:"leaf"},{id:"find-indices",data:{label:"Find or enumerate indices?"},position:{x:100,y:6100},type:"diamond"},{id:"find-indices-monotonic",data:{label:"Monotonic Condition?"},position:{x:500,y:6200},type:"diamond"},{id:"find-indices-twopointers",data:{label:"Two pointers"},position:{x:900,y:6300},type:"leaf"},{id:"constant-memory",data:{label:"O(1) memory required"},position:{x:100,y:6500},type:"diamond"},{id:"constant-memory-monotonic",data:{label:"Involves monotonic condition?"},position:{x:500,y:6600},type:"diamond"},{id:"constant-memory-twopointers",data:{label:"Two pointers"},position:{x:900,y:6700},type:"leaf"},{id:"parse-symbols",data:{label:"Do you need to parse symbols?"},position:{x:100,y:6900},type:"diamond"},{id:"parse-symbols-stack",data:{label:"Stack"},position:{x:500,y:7e3},type:"leaf"}],v=[{id:"max/min-monotonichuh",source:"max/min",target:"max/min-monotonic",data:{label:"yes"},type:"custom"},{id:"max/min-binarysearch-yes",source:"max/min-monotonic",target:"max/min-binarysearch",data:{label:"yes"},type:"custom"},{id:"max/min-subproblemhuh",source:"max/min-monotonic",target:"max/min-subproblem",data:{label:"no"},type:"custom"},{id:"max/min-dp-yes",source:"max/min-subproblem",target:"max/min-dp",data:{label:"yes"},type:"custom"},{id:"max/min-isgreedy",source:"max/min-subproblem",target:"max/min-greedyhuh",data:{label:"no"},type:"custom"},{id:"max/min-no",source:"max/min",target:"counting",data:{label:"no"},type:"custom"},{id:"2-sequence-multiple-no",source:"sequence-count",target:"find-indices",data:{label:"no"},type:"custom"},{id:"2-sequence-multiple-yes",source:"sequence-count",target:"sequence-count-monotonic",data:{label:"yes"},type:"custom"},{id:"2-sequence-twopointers",source:"sequence-count-monotonic",target:"sequence-count-twopointers",data:{label:"yes"},type:"custom"},{id:"2-sequence-subproblems",source:"sequence-count-monotonic",target:"sequence-count-subproblems",data:{label:"no"},type:"custom"},{id:"2-sequence-dp",source:"sequence-count-subproblems",target:"sequence-count-dp",data:{label:"yes"},type:"custom"},{id:"find-indices-monotonichuh",source:"find-indices",target:"find-indices-monotonic",data:{label:"yes"},type:"custom"},{id:"find-indices-yes",source:"find-indices-monotonic",target:"find-indices-twopointers",data:{label:"yes"},type:"custom"},{id:"find-indices-no",source:"find-indices",target:"constant-memory",data:{label:"no"},type:"custom"},{id:"subarrays-yes",source:"subarrays",target:"subarrays-twopointers",data:{label:"yes"},type:"custom"},{id:"sums-yes",source:"sums",target:"subarrays-prefixsums",data:{label:"yes"},type:"custom"},{id:"sums-no",source:"sums",target:"subarrays",data:{label:"no"},type:"custom"},{id:"subarrays-no",source:"subarrays",target:"max/min",data:{label:"no"},type:"custom"},{id:"constant-memory-monotonichuh",source:"constant-memory",target:"constant-memory-monotonic",data:{label:"yes"},type:"custom"},{id:"constant-memory-twopointers-yes",source:"constant-memory-monotonic",target:"constant-memory-twopointers",data:{label:"yes"},type:"custom"},{id:"max/min-greedy-yes",source:"max/min-greedyhuh",target:"max/min-greedy",data:{label:"yes"},type:"custom"},{id:"counting-efficiencyhuh",source:"counting",target:"counting-efficiency",data:{label:"yes"},type:"custom"},{id:"counting-bruteforce/backtracking-yes",source:"counting-efficiency",target:"counting-bruteforce/backtracking",data:{label:"yes"},type:"custom"},{id:"counting-dp-yes",source:"counting-efficiency",target:"counting-dp",data:{label:"no"},type:"custom"},{id:"counting-no",source:"counting",target:"sequence-count",data:{label:"no"},type:"custom"},{id:"linked-list-twopointers-yes",source:"linked-list",target:"linked-list-twopointers",data:{label:"yes"},type:"custom"},{id:"linked-list-no",source:"linked-list",target:"small-constraints",data:{label:"no"},type:"custom"},{id:"kth-smallest-yes",source:"kth-smallest",target:"kth-smallest-heap",data:{label:"yes"},type:"custom"},{id:"kth-smallest-no",source:"kth-smallest",target:"linked-list",data:{label:"no"},type:"custom"},{id:"small-constraints-efficiencyhuh",source:"small-constraints",target:"small-constraints-efficiency",data:{label:"yes"},type:"custom"},{id:"small-constraints-bruteforce/backtracking-yes",source:"small-constraints-efficiency",target:"small-constraints-bruteforce/backtracking",data:{label:"yes"},type:"custom"},{id:"small-constraints-dp-yes",source:"small-constraints-efficiency",target:"small-constraints-dp",data:{label:"no"},type:"custom"},{id:"small-constraints-no",source:"small-constraints",target:"sums",data:{label:"no"},type:"custom"},{id:"graph-yes",source:"graph",target:"tree",data:{label:"yes"},type:"custom"},{id:"graph-no",source:"graph",target:"kth-smallest",data:{label:"no"},type:"custom"},{id:"tree-yes",source:"tree",target:"tree-dfs",data:{label:"yes"},type:"custom"},{id:"tree-no",source:"tree",target:"directed-graph",data:{label:"no"},type:"custom"},{id:"directed-yes",source:"directed-graph",target:"directed-graph-topo",data:{label:"yes"},type:"custom"},{id:"directed-no",source:"directed-graph",target:"shortest-path",data:{label:"no"},type:"custom"},{id:"shortest-path-yes",source:"shortest-path",target:"shortest-path-weighted",data:{label:"yes"},type:"custom"},{id:"shortest-path-no",source:"shortest-path",target:"connectivity",data:{label:"no"},type:"custom"},{id:"shortest-path-weighted-yes",source:"shortest-path-weighted",target:"shortest-path-dijkstra",data:{label:"yes"},type:"custom"},{id:"shortest-path-weighted-no",source:"shortest-path-weighted",target:"shortest-path-bfs",data:{label:"no"},type:"custom"},{id:"connectivity-yes",source:"connectivity",target:"connectivity-dsu",data:{label:"yes"},type:"custom"},{id:"connectivity-no",source:"connectivity",target:"graph-smallcontraints",data:{label:"no"},type:"custom"},{id:"graph-smallcontraints-yes",source:"graph-smallcontraints",target:"graph-smallcontraints-dfs",data:{label:"yes"},type:"custom"},{id:"graph-smallcontraints-no",source:"graph-smallcontraints",target:"graph-smallcontraints-bfs",data:{label:"no"},type:"custom"},{id:"constant-memory-no",source:"constant-memory",target:"parse-symbols",data:{label:"no"},type:"custom"},{id:"parse-symbols-yes",source:"parse-symbols",target:"parse-symbols-stack",data:{label:"yes"},type:"custom"}],k={"sequence-count":'\n  ## How many sequences?\n  Is the problem involve multiple sequences? Does it involve comparing/analyzing two sequences?\n\n  Examples of such problem:\n  * [Longest Word in Dictionary through Deleting](/liteproblems/524):\n    * "Given a string `s` and a string array `dictionary`, return the longest string in the dictionary that can be formed by deleting some of the given string characters. "\n  * [Swap Adjacent in LR String](/liteproblems/777):\n    * "Given the **starting string** `start` and the **ending string** `end`"\n    * "transform one string to the other"\n  * [Longest Common Subsequence](/problems/longest_common_subsequence)\n    * Given **two strings** `text1` and `text2`, return the length of their longest common subsequence\n  * [Merge Sorted Array](/liteproblems/88):\n    * "You are given two integer arrays `nums1` and `nums2`"\n    * "Merge `nums1` and `nums2` into a single array sorted in non-decreasing order"\n\n  ',"sequence-count-monotonic":'\n  ## [Monotonic Condition](https://algo.monster/problems/binary-search-monotonic)\n  Monotonicity simply means either entirely non-increasing or entirely non-decreasing.\n  In the context of a two-pointer algorithm, the monotonic condition represents a constraint that the algorithm should follow.\n  We just need to find some property that\'s entirely non-increasing or entirely non-decreasing.\n\n  Examples with multiple sequences:\n  * [Swap Adjacent in LR String](/liteproblems/777):\n    * Notice that when we can only swap `"XL"` with `"LX"`, the character `\'L\'` can only move towards the left\n    * When we swap `"RX"` with `"XR"`, the character `\'R\'` can only move towards the right\n  * [Merge Sorted Array](/liteproblems/88)\n    * This one is easier: the arrays are non-decreasing\n  * [Interval List Intersections](/liteproblems/986)\n    * The intervals here are also given in sorted order, making it obvious two pointers can be applicable\n\n  ',"sequence-count-twopointers":"\n  ## [Two Pointers](https://algo.monster/problems/two_pointers_intro)\n  The two-pointer technique simplifies problems related\n  to two sequential elements like arrays or linked lists. When approaching issues that involve comparing,\n  merging, or analyzing two distinct sequences, the utilization of two pointers could significantly reduce\n  time complexity. In this techinque, each array will be traversed with its individual pointer. It's important to\n  notice that one sweep with two-pointers will run in linear time.\n\n  These problems involve multiple sequences and can be solved using two pointers:\n\n  1. [LeetCode #88: Merge Sorted Array](/liteproblems/88)\n    - Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. This can be solved using two pointers, each iterating over the arrays from the end, and filling the merged array from the end.\n\n  2. [LeetCode #524: Longest Word in Dictionary through Deleting](/liteproblems/524)\n    - Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. This problem can be solved by using two pointers to compare each string in the dictionary with the given string.\n\n  4. [LeetCode #350: Intersection of Two Arrays II](/liteproblems/349)\n    - Given two integer arrays nums1 and nums2, return an array of their intersection. This problem can be solved using two pointers if the given arrays are sorted, or by sorting them first.\n\n\n  ","sequence-count-subproblems":"\n  ## Overlapping Sub-problems\n  The best sign that a problem can be solved using dynamic programming is the presence of overlapping subproblems, meaning the problem can be broken down into smaller yet similar problems.\n  If you notice that you are computing the same smaller problem multiple times or the recursive solution for the problem has a slow time complexity,\n  it is an indicator that the problem can be broken into overlapping sub-problems.\n\n  Examples of problems with multiple sequences that have this property:\n  * [Edit Distance](/problems/edit_distance)\n    * Sub-problem: Solve minimum edit distance on string `s` and string `t` where `s` is a prefix of `word` and `t` is a prefix of `word2`\n  * [Distinct Subsequences](/liteproblems/115)\n    * Sub-problem: Count number of distinct subsequences of string `s2` equal to string `t2`, where `s2` is a prefix of `s` and `t2` is a prefix of `t`.\n  * [Longest Common Subsequence](/problems/longest_common_subsequences)\n    * Sub-problem: Find longest common subsequence of string `s` and string `t`, where `s` is a prefix of `text1` and `t` is a prefix of `text2`.\n  * [Shortest Common Supersequence](/liteproblems/1092)\n    * Sub-problem: Find shortest string that contains both string `s` and string `t` as a subsequence, where `s` is a prefix of `str1` and `t` is a prefix of `str2`\n\n  ","sequence-count-dp":'\n  ## [Dynamic Programming](https://algo.monster/problems/dynamic_programming_intro)\n  Using dynamic programming to solve problems related to analyzing or comparing two sequences will usually have this\n  state: `dp[prefix of first sequence considered][prefix of second sequence considered]` stores the answer to the overlapping subproblem,\n  making the time complexity at least `O(NM)`, where `N` and `M` represent the length of the two sequences.\n\n  Learn about [Dual-sequence dynamic programming](/problems/dp_two_sequence_intro) or watch the dual-sequence section of the DP video:\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/9k31KcQmS_U?si=nEC14fKchw1LZY1w&amp;start=1341" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  ',"find-indices":'\n  ## Searching pairs of indices?\n  Does this problem involve searching/enumerating pairs of indices?\n  This can be answered by looking for specific phrases in the problem statement such as "count pairs `i < j`" and "find two elements\n  in the array where...".\n\n  Examples:\n  * [Valid Triangle Number](/liteproblems/611):\n    * "return the number of **triplets** chosen from the array that can..."\n    * Finding triplets is similar to finding pairs since a pair is part of a triplet\n  * [Find K-th Smallest Pair Distance](/liteproblems/719):\n    * "distance among all the **pairs** `nums[i]` and `nums[j]`"\n  * [Max Number of K-Sum Pairs](https://leetcode.com/problems/max-number-of-k-sum-pairs/):\n    * "you can pick **two numbers** from the array whose sum equals k"\n  ',"find-indices-monotonic":"\n  ## [Monotonic Condition]((https://algo.monster/problems/binary-search-monotonic))\n  Monotonicity simply means either entirely non-increasing or entirely non-decreasing.\n  In the context of a two-pointer algorithm, the monotonic condition represents a constraint that the algorithm should follow.\n\n  We just need to find some property that's entirely non-increasing or entirely non-decreasing. If there isn't any obvious property, we should\n  also consider sorting to make the array monotonic and then checking for a way to implement two pointers into the solution.\n\n  Examples with sorting:\n  * [Max Number of K-Sum Pairs](https://leetcode.com/problems/max-number-of-k-sum-pairs/)\n  * [Boat to Save People](/liteproblems/881)\n  * [Valid Triangle Number](/liteproblems/661)\n  ","find-indices-twopointers":'\n  ## [Two pointers](https://algo.monster/problems/two_pointers_intro)\n  We need establish the two pointers that will traverse the array. When looking for pairs of indices `i < j`, one pointer\n  will refer to the first element `i` and the other will refer to `j`. These two pointers can collectively enumerate\n  different pairs of indices based on specific conditions provided in the problem.\n\n  For a quick introduction of the Two Pointers technique, check out this video:\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/xZ4AfXHQ1VQ?si=ZUxkwiJ2ncwryTo1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  In certain problems, we might be tasked with enumerating triplets rather than pairs of indices. A strategy\n  for tackling this would be to fix one position for the triplet and execute an iteration of the\n  two-pointer technique to determine the remaining two triplet positions.\n\n  These problems involve either pairs or triplets of indices and can be solved using two pointers:\n\n\n  1. [Problem #881: Boats to Save People](/liteproblems/881)\n     - The i-th person has a weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. It is guaranteed each person can be carried by a boat. This problem can be solved using two pointers. The intuition behind this approach is that if the heaviest person can share a boat with the lightest person, then they do. Otherwise, the heaviest person can\'t pair with anyone, so they get their own boat.\n\n  2. [Problem #611: Valid Triangle Number](/liteproblems/611)\n     - Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. This problem can be solved by first sorting the array and then using two pointers. For each iteration, we fix one side of the triangle and move the two pointers to find the other two sides.\n\n  3. [Problem #1672: Max Number of K-Sum Pairs](https://leetcode.com/problems/max-number-of-k-sum-pairs/)\n     - In this problem, you are given an integer array nums and an integer k. You are supposed to find the maximum number of pairs you can form such that their sum is equal to k. The two pointers in this problem can start from the two ends of the sorted array. If the sum of two numbers pointed by the two pointers is equal to k, we found one pair and move both pointers towards the middle. If the sum is less than k, we move the left pointer to the right; if the sum is more than k, we move the right pointer to the left.\n  ',subarrays:'\n  ## Involves subarrays\n  The pattern in question can be easily recognized by searching for the term "subarray" within the problem statement.\n  However, it\'s important to note that "subarrays" may appear in various forms, such as "substrings" or\n  "submatrices/rectangles."\n\n  Examples:\n  * [Subarray Sums Divisible by K](/liteproblems/974):\n    * "return the number of non-empty **subarrays**..."\n  * [Longest Substring Without Repeating Characters](/problems/longest_substring_without_repeating_characters):\n    * "find the length of the longest **substring** without repeating characters"\n  * [Max Sum of Rectangle No Larger Than K](/liteproblems/363):\n    * "return the max sum of a **rectangle** in the matrix such that..."\n  * [Subarray Sum Equals K](/liteproblems/560):\n    * "return the total number of **subarrays**...""\n  ',sums:'\n  ## Involves sums or additive\n  This pattern can be identified by the term "sum" in the problem or any indicator that we\'ll need to take/analyze/compare sums.\n\n  Here are some examples:\n  * [Max Sum of Rectangle No Larger Than K](/liteproblems/363)\n    * "return the max **sum** of a rectangle in the matrix such that its **sum** is no larger than `k`"\n  * [Continuous Subarray Sum](/liteproblems/523)\n    * "the **sum** of the elements of the subarray is a multiple of k"\n  * [Subarray Sum Equals K](/liteproblems/560)\n    * return the total number of subarrays whose **sum** equals to `k`\n  ',"subarrays-prefixsums":"\n  ## [Prefix Sums](https://algo.monster/problems/subarray_sum)\n  Prefix sums is a technique used to calculate the sum of elements in an array up to a specific index. We store the prefix sums in a separate array,\n  which we use to quickly compute the sum of elements in a subarray when needed. This optimization is useful as it allows us to calculate the sum of any subarray in constant time.\n\n  ","subarrays-twopointers":'\n  ## [Sliding Window](https://algo.monster/problems/subarray_sum_fixed)\n  The sliding window technique refers to maintaining a continuous segment, or "window," of elements, usually within an array or string.\n  The window will represent a subarray, which makes this technique useful to solve problems related to subarrays/substrings.\n  The sliding window can be of two types:\n  * [Fixed-size sliding window](https://algo.monster/problems/subarray_sum_fixed)\n    * The window size remains constant throughout the process, and only the position of the window within the data structure shifts.\n  * [Variable-size sliding window](https://algo.monster/problems/subarray_sum_longest)\n    * The window size expands or contracts based on the problem\'s constraints, along with its movement within the data structure.\n  This is implemented with two pointers, with the pointers indicating the left/right borders of the window.\n  ',"constant-memory":"\n  ## O(1) memory\n  Does the problem statement specifically ask for `O(1)` memory or ask for the memory to be optimized to `O(1)`?\n  This pattern is quite easy to spot but is quite uncommon.\n\n  Examples of problems that ask for this condition:\n  * [Linked List Cycle](/problems/linked_list_cycle)\n    * Follow up: Can you solve it using **O(1) (i.e. constant) memory**?\n  * [Intersection of Two Linked Lists](/liteproblems/160)\n    * Follow up: Could you write a solution that runs in O(m + n) time and use only **O(1) memory**?\n  * [Circular Array Loop](/liteproblems/457)\n    * Follow up: Could you solve it in O(n) time complexity and **O(1) extra space complexity**?\n  * [Longest Mountain in Array](/liteproblems/845)\n    * **Can you solve it in O(1) space?**\n  ","constant-memory-monotonic":"\n  ## [Monotonic Condition](https://algo.monster/problems/binary-search-monotonic)\n  Monotonicity simply means either entirely non-increasing or entirely non-decreasing.\n  In the context of a two-pointer algorithm, the monotonic condition represents a constraint that the algorithm should follow.\n\n  We just need to find some property that's entirely non-increasing or entirely non-decreasing. If there isn't any obvious property, we should\n  also consider sorting to make the array monotonic and then checking for a way to implement two pointers into the solution.\n  Note that sorting the array won't use extra space.\n\n\n  ","constant-memory-twopointers":"\n  ## [Two pointers](https://algo.monster/problems/two_pointers_intro)\n  When implementing a generic [two pointers](https://algo.monster/problems/two_pointers_intro) solution, here are some things we should think about:\n  * What the pointers are pointing at\n  * When to move the pointers\n  * What direction the pointers are moving in\n\n  Examples:\n\n  1. [LeetCode #26: Remove Duplicates from Sorted Array](/problems/remove_duplicates)\n    - Given a sorted array nums, remove the duplicates in-place such that each element appears only once and return the new length. Here, two pointers are used to track the last non-duplicate element and the current element being considered, thus allowing in-place modification of the array.\n\n  2. [LeetCode #283: Move Zeroes](/problems/move_zeros)\n    - Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements. In this problem, two pointers are used to keep track of the last non-zero element and the current element being considered, allowing for in-place modification of the array.\n  ","max/min":'\n  ## Max/min problems\n  This type of problem will ask you to calculate the maximum/minimum possible answer of something. Typically, the problem will be\n  about minimizing/maximizing profit or cost, or time spent to accomplish some task. We can identify this from some keywords\n  in the problem statement such as max/min, minimize/maximize, shortest/longest, least/greatest, etc.\n  Examples of problems under this category:\n  * [Minimum Path Sum](/liteproblems/64):\n    * "which **minimizes** the sum of all numbers along its path"\n  * [Maximize Sum Of Array After K Negations](/liteproblems/1005):\n    * "Return the **largest** possible sum of the array after modifying it in this way"\n  * [Maximum Length of Repeated Subarray](/liteproblems/718):\n    * "return the **maximum** length of a subarray that appears in both arrays"\n  * [Capacity To Ship Packages Within D Days](/liteproblems/1011)\n    * "Return the **least** weight capacity of the ship that will result in all the packages..."\n  * [Maximum Candies Allocated to K Children](/liteproblems/2226)\n    * "Return the **maximum** number of candies each child can get."\n  ',"max/min-subproblem":"\n  ## Overlapping Sub-problems\n  The best sign that a problem can be solved using dynamic programming is the presence of overlapping subproblems, meaning the problem can be broken down into smaller yet similar problems.\n\n  If you notice that you are computing the same smaller problem multiple times or the recursive solution for the problem has a slow time complexity,\n  it is an indicator that the problem can be broken into overlapping sub-problems.\n\n  Since we're solving a max/min problem, we should notice that a subproblem should also solve for max/min of something.\n  Examples of problems with multiple sequences that have this property:\n  * [Edit Distance](/problems/edit_distance)\n    * Sub-problem: Solve minimum edit distance on string `s` and string `t` where `s` is a prefix of `word` and `t` is a prefix of `word2`\n  * [Minimum Path Sum](/problems/minimal_path_sum)\n    * Sub-problem: Solve minimum path sum for a path from the top left to some cell `(i,j)` for all cells `(i,j)`\n  * [Maximal Square](/problems/maximal_square)\n    * Sub-problem: At every cell `(i,j)` find the largest square containing only ones with the square's bottom-right corner located at `(i,j)`\n  * [Maximum Length of Repeated Subarray](/liteproblems/718)\n    * Sub-problem: For every possible pair of `i` and `j`, find the maximum repeated array length that ends at index `i` in `nums1` and at index `j` in `nums2`\n  ","max/min-dp":'\n  ## [Dynamic Programming](https://algo.monster/problems/dynamic_programming_intro)\n  Once we\'ve identified that a problem could be dynamic programming, we should think about the following:\n  * How exactly to break down the main problem into sub-problems (i.e. a recursive formula)\n    * Note that your sub problem should solve for the same max/min value but on a smaller problem\n  * How to use answers from sub-problems to solve a bigger sub-problem or the main problem (i.e. transition between states)\n  * The base cases and the answers to them\n\n  For a breakdown of DP patterns, check out this video (1.5h):\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/9k31KcQmS_U?si=nEC14fKchw1LZY1w&amp;start=1341" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  ',"max/min-monotonic":"\n  ## [Monotonicity](https://algo.monster/problems/binary-search-monotonic) in min/max problems\n  Monotonic means either entirely non-increasing or entirely non-decreasing. Binary search is only applicable directly on\n  a function that's monotonic so a good sign a problem involves binary search is if you can identify some relevant monotonic\n  property.\n\n  Frequently, when we binary search on a function, the function is simply just an array. However, this function might not directly be an array and\n  you may have to [\"binary search for the answer\"](https://algo.monster/problems/binary-search-monotonic).\n\n  Examples of various min/max problems with a monotonic property:\n  * [Find Minimum in Rotated Sorted Array](/problems/min_in_rotated_sorted_array)\n    * \"Given the **sorted** rotated array `nums` of unique elements\"\n  * [Max Consecutive Ones III](/liteproblems/1004)\n    * If some answer `t` is possible, then `t - 1` is also possible because we can find `t - 1` consecutive ones in a list of `t` consecutive ones.\n    * In addition, if `t` isn't possible, then `t + 1` will also not be possible for similar reasons\n    * Thus, we can perform a binary search for the answer\n  * [Koko Eating Bananas](/liteproblems/875)\n    * If some answer `k` works, then `k + 1` will also work, because Koko will take equal or less time to eat all the bananas\n    * Similarly, if `k` doesn't work, then `k - 1` won't work\n  * [Capacity To Ship Packages Within D Days](/liteproblems/1011)\n    * If the task can be completed with some capacity `w`, then it will always be possible to do the task with capacity `w + 1`\n    * If it's impossible to do the task with capacity `w`, then `w - 1` will also be impossible\n  * [Maximum Candies Allocated to K Children](/liteproblems/2226)\n    * If we can allocate `k` candies to each child, it's also possible to allocate `k - 1` candies to each child\n    * If it's impossible to allocate `k` candies to each child, allocating `k - 1` candies is also impossible\n  ","max/min-binarysearch":"\n\n  ## [Binary Search](https://algo.monster/problems/binary-search-monotonic)\n  Binary searching on an array is pretty simple and is described [here](https://algo.monster/problems/binary_search_intro).\n\n  The idea of binary searching on a monotonic function is described [here](https://algo.monster/problems/binary-search-monotonic).\n  If we're binary searching on a monotonic function, we should think about the following:\n  * How to check if some input in the function is `'T'` or `'F'`?\n  * Are we trying to find the highest `'F'` or lowest `'T'`?\n  * What is the maximum range (i.e. interval) that we need to cover?\n\n  ","max/min-greedyhuh":"\n  ## [Greedy Algorithms](/problems/greedy_intro)\n  Greedy algorithms are problem solving techniques that solve problems which involve making a sequence of decisions.\n  In a max/min problem, you want to find the sequence of decisions that leads to the max/min value you want to solve.\n  A greedy algorithm will always pick the best option at any decision point to reach the max/min value.\n\n  A greedy algorithm will solve a problem if picking the best option at every decision point is always optimal to the final\n  answer. To get good intuition if some greedy algorithm is optimal, we should try testing the idea on the sample input\n  or coming up with small test cases ourselves.\n\n  Examples of problems that use a greedy approach:\n  * [Patching Array](liteproblems/330)\n    * Greedy decision: Always add the smallest element that can't be formed as a sum\n  * [Non-overlapping Intervals](/liteproblems/435)\n    * Want to find maximum number of intervals that don't overlap each other\n    * Greedy decision: Choose a non-overlapping interval that ends the earliest\n  * [Minimum Number of Arrows to Burst Balloons](/liteproblems/452)\n    * First sort all balloons by their `x_start` value\n    * Greedy decision: Pick the largest prefix of balloons that can be popped with one arrow and remove them\n  * [Most Profit Assigning Work](/liteproblems/826)\n    * Greedy decision: For a worker, let it work the best paying job with a difficulty it can handle\n  ","max/min-greedy":'\n  ## Greedy Algorithms\n\n  Once we\'ve identified a problem could use greedy, we should come up with the greedy strategy which determines\n  the "best" choice we make at every decision point. Most greedy problems are different and will require a different\n  "best" choice. To show a greedy algorithm works, we should consider\n  if it\'s ever possible that not taking the most optimal choice at every decision point can lead to the best answer.\n  We can do this by testing the algorithm on some small test cases by hand.\n\n  For more detailed discussion and examples, check out this video:\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/-WTslqPbj7I?si=ZbBAB-GhbtoB4uuK" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  ',counting:'\n\n  ## Counting\n  In a counting problem, the statement will ask for the number of ways to accomplish a task, arrange items, or satisfy certain conditions.\n  This could be expressed as phrases such as "how many ways," "number of," or "total possible ways."\n\n  Examples:\n  * [Unique Paths II](/liteproblems/63)\n    * "Return the **number of** possible unique paths that the robot can take to reach the bottom-right corner"\n  * [Combinations](/liteproblems/77)\n    * "return **all possible combinations** of `k` numbers chosen from the range `[1, n]`"\n  * [Decode Ways](/problems/decode_ways)\n    * "return **the number of ways** to decode it"\n  * [N-Queens II](/liteproblems/52)\n    * "return the **number of distinct solutions** to the n-queens puzzle"\n  ',"counting-efficiency":'\n\n  ## Is brute force fast enough?\n  A brute force/[backtracking](https://algo.monster/problems/backtracking) algorithm for a counting problem will iterate through all possible answers to count the number of ways to accomplish a task.\n\n  To determine if a specific brute force algorithm will run in time, we should estimate the time complexity and use the constraints to\n  make an educated guess of whether or not an algorithm will pass.\n\n  Check out this video to understand how constraints can be used to estimate time complexity:\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/eB7SMsE6qEc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  Or check out the [Runtime Summary](https://algo.monster/problems/runtime_summary) section.\n\n  A brute force algorithm will usually have an exponential or factorial time complexity.\n\n  If the input constraint is really small (`25` or less),\n  Examples of problems where brute force passes:\n  * [N-Queens II](/liteproblems/52):\n    * `O(N!)` combinations to iterate through\n    * `N <= 9` so this solution is fast enough\n  * [Combinations](/liteproblems/77):\n    * Since there are `N` numbers, we have `2^N` combinations\n    * `N <= 20` so this solution works\n  * [Palindrome Partitioning](/problems/palindrome_partitioning)\n    * Let `N` be the length of the string\n    * Since there are `O(N)` positions to consider, we have `O(2^N)` possible partitions to try\n    * `N <= 16` so our solution works\n\n  If a brute force solution is really hard to identify, the problem will probably use dynamic programming.\n  ',"counting-dp":'\n\n  ## [Dynamic Programming](https://algo.monster/problems/dynamic_programming_intro)\n  If a counting problem isn\'t trivial to count and brute force is too slow, then most likely we\'ll use dynamic programming.\n\n  Here are the steps the solving a counting problem with dynamic programming:\n  * Identify an overlapping subproblem, which will be counting the number of ways on a smaller problem\n  * Identify how to use answers from sub-problems to solve a bigger sub-problem or the main problem (i.e. transition between states)\n  * Identify the base cases and the answers to them\n  * Check for any edge cases (i.e. where the count is 0)\n\n  For a breakdown of the DP patterns, check out this video:\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/9k31KcQmS_U?si=SJlJTKfQgcydDvDI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  ',"counting-bruteforce/backtracking":"\n\n  ## Brute Force/[Backtracking](https://algo.monster/problems/backtracking)\n  Steps to implement backtracking\n  * Draw the space-state tree\n  * Traverse the tree using recursion\n  * Prune the tree using the constraints\n\n  Check out the [backtracking](https://algo.monster/problems/backtracking) section for more details.\n\n  ","linked-list":"\n\n  ## Linked List\n  Linked list problems are trivial to identify. We can just look at whether or not the problem mentioned anything about\n  a linked list. These problems will often require us to traverse the linked list in some way.\n\n  Examples of linked list problems that use two pointers:\n  * [Merge Two Sorted Lists](/problems/merge_two_sorted_lists)\n  * [Odd Even Linked List](/liteproblems/328)\n  * [Partition List](/liteproblems/86/)\n  * [Remove Duplicates from Sorted List II](/liteproblems/82)\n  ","linked-list-twopointers":"\n\n  ## [Two pointers](https://algo.monster/problems/two_pointers_intro)\n  Most linked list problems are about singly-linked list that can be solved with a simple traversal. However, some problems may require two pointers.\n\n  Two pointers is a common technique used to solve linked list problems. It involves maintaining two pointers on the linked-list\n  at **different speed** ([tortoise and hare algorithm](https://algo.monster/problems/linked_list_cycle)) and/or **intervals** (e.g. [Middle of a Linked List](https://algo.monster/problems/middle_of_linked_list), [Remove Nth Node From End of List](/liteproblems/19). Here are a few more examples:\n\n  #### Problems Solved Using Slow-Fast Pointers\n\n  These problems typically involve finding a cycle or a specific location in the list.\n\n  1. [LeetCode #876: Middle of the Linked List](/problems/middle_of_linked_list)\n    - Fast and slow pointers start at the head. The slow pointer moves one node at a time, while the fast pointer moves two nodes at a time. By the time the fast pointer reaches the end, the slow pointer will be at the middle of the list.\n\n  2. [LeetCode #234: Palindrome Linked List](/liteproblems/234)\n    - Fast and slow pointers are used to find the middle of the linked list. After finding the middle, reverse the second half of the linked list. Then, compare the first half and the second half to check if it's a palindrome.\n\n  3. [LeetCode #141: Linked List Cycle](/problems/linked_list_cycle)\n    - Fast and slow pointers start at the head. The slow pointer moves one node at a time, while the fast pointer moves two nodes at a time. If there is a cycle, the fast pointer will eventually catch up to the slow pointer. If there is no cycle, the fast pointer will reach the end of the list. Also known as the [tortoise and hare algorithm](https://algo.monster/problems/linked_list_cycle).\n\n\n  #### Problems Solved Using Two Pointers With an Interval\n\n  These problems often involve changing the list in some way, such as deletion or rotation.\n\n  1. [LeetCode #19: Remove Nth Node From End of List](/liteproblems/19)\n    - Two pointers start at the head, with one pointer n steps ahead of the other. When the ahead pointer reaches the end, the other pointer will be at the node before the node to be deleted. Deleting the next node of this pointer will remove the nth node from the end of the list.\n\n  2. [LeetCode #21: Merge Two Sorted Lists](/problems/merge_two_sorted_lists)\n    - Two pointers are used to traverse the two sorted lists respectively. Compare the current nodes the pointers point to, and always take the smaller one to merge into the new list.\n\n  3. [LeetCode #61: Rotate List](/liteproblems/61)\n    - Two pointers are used to find the length of the linked list first. Then, move the second pointer to the (length - k % length - 1)th node. The next node of this pointer will be the new head after rotation.\n\n  4. [LeetCode #160: Intersection of Two Linked Lists](/liteproblems/160)\n    - Two pointers start at the head of each list. When one pointer reaches the end of a list, move it to the head of the other list. If the two lists intersect, the pointers will eventually meet at the intersection node.\n\n\n\n  ","kth-smallest":'\n\n  ## Kth smallest/largest\n  Does the problem specifcally ask you to solve for the **kth** smallest/largest value of something?\n  This is pretty simple to identify in the problem statement and the phrase may also appear in the title of the problem.\n\n  Examples of kth-smallest/largest problems:\n  * [Top K Frequent Elements](/liteproblems/347)\n    * "return the **k most frequent** elements"\n  * [Kth Smallest Element in a Sorted Matrix](/problems/kth_smallest_element_in_a_sorted_matrix)\n    * "return the **kth smallest element** in the matrix"\n  * [Top K Frequent Words](/problems/top_k_frequently_mentioned_keywords)\n    * "return the **k most frequent** strings"\n  * [Find K Closest Elements](/liteproblems/658)\n    * "return the **k closest integers** to x in the array"\n  ',"kth-smallest-heap":"\n  ## Sorting and [Heaps](https://algo.monster/problems/heap_intro)\n\n  When we're asked to find the kth smallest or largest elements, the first method that comes to mind is to use a min/max\n  [heap](https://algo.monster/problems/heap_intro) or sorting.\n\n  Heap is faster than sorting when it comes finding kth smallest/largest element because it does not require sorting the entire list. Very rarely, you may need to use [treemap](https://algo.monster/problems/python-treemap) data structure. More examples:\n\n  - [LeetCode #215: Kth Largest Element in an Array](/problems/kth_largest_element_in_an_array)\n    - Find the kth largest element in an unsorted array. A min-heap can be used to sort the elements and then find the kth largest one.\n\n  - [LeetCode #347: Top K Frequent Elements](/liteproblems/347)\n    - Given a non-empty array of integers, return the k most frequent elements. A max-heap can be used to track the frequency of each integer and return the k most frequent.\n\n  - [LeetCode #378: Kth Smallest Element in a Sorted Matrix](/problems/kth_smallest_element_in_a_sorted_matrix)\n    - Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. You can use a min-heap to keep track of the smallest elements seen so far.\n\n  - [LeetCode #313: Super Ugly Number](/liteproblems/313)\n    - A super ugly number is a positive integer for which the prime factors are in a given sorted array of primes. We need to find the nth super ugly number. A min-heap can be used to sequentially create each super ugly number from smallest to largest.\n\n  - [LeetCode #373: Find K Pairs with Smallest Sums](/liteproblems/373)\n    - You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. You need to find the k pairs (u, v) where u is in nums1 and v is in nums2 with the smallest sums. You can use a min-heap to solve this problem by storing the sums and the indices of the elements from both arrays that make up the sum.\n\n  ","small-constraints":"\n  ## Small constraints\n  To tell that a problem has small constraints, we should look at the input size or the constraint about size of input,\n  which is generally written as `n` or `length`. We'll consider an input size small if the complexity is cubic or slower.\n  Generally, `size <= 500` for cubic time.\n\n  Theses are often [combinatorial problems](https://algo.monster/problems/backtracking), such as [permutations](https://algo.monster/problems/permutations) or [subsets](https://algo.monster/problems/subsets).\n\n  Examples of problems with small constraints:\n  * [Minimum Falling Path Sum](/liteproblems/931)\n    * `n == matrix.length == matrix[i].length`\n    * `1 <= n <= 100`\n  * [N-Queens](/liteproblems/51)\n    * `1 <= n <= 9`\n  * [Count Square Submatrices with All Ones](/liteproblems/1504)\n    * `1 <= arr.length <= 300`\n  * [Unique Paths](/problems/robot_unique_path)\n    * `1 <= m, n <= 100`\n\n  ","small-constraints-efficiency":'\n  ## Is brute force fast enough?\n  A brute force/[backtracking](https://algo.monster/problems/backtracking) algorithm for a counting problem will iterate through all possible answers to count the number of ways to accomplish a task.\n\n  To determine if a specific brute force algorithm will run in time, we should estimate the time complexity and use the constraints to\n  make an educated guess of whether or not an algorithm will pass.\n\n  Check out this video to understand how constraints can be used to estimate time complexity:\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/eB7SMsE6qEc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  Or check out the [Runtime Summary](https://algo.monster/problems/runtime_summary) section.\n\n  A brute force algorithm will usually have an exponential or factorial time complexity.\n\n  If the input constraint is really small (`25` or less),\n  Examples of problems where brute force passes:\n  * [N-Queens II](/liteproblems/52):\n    * `O(N!)` combinations to iterate through\n    * `N <= 9` so this solution is fast enough\n  * [Combinations](/liteproblems/77):\n    * Since there are `N` numbers, we have `2^N` combinations\n    * `N <= 20` so this solution works\n  * [Palindrome Partitioning](/problems/palindrome_partitioning)\n    * Let `N` be the length of the string\n    * Since there are `O(N)` positions to consider, we have `O(2^N)` possible partitions to try\n    * `N <= 16` so our solution works\n\n  If a brute force solution is really hard to identify, the problem will probably use dynamic programming.\n  ',"small-constraints-bruteforce/backtracking":"\n\n  ## Brute Force/[Backtracking](https://algo.monster/problems/backtracking)\n  Steps to implement backtracking\n  * Draw the space-state tree\n  * Traverse the tree using recursion\n  * Prune the tree using the constraints\n\n  Check out the [backtracking](https://algo.monster/problems/backtracking) section for more details.\n\n  ","small-constraints-dp":'\n\n  ## [Dynamic Programming](https://algo.monster/problems/dynamic_programming_intro)\n  If a counting problem isn\'t trivial to count and brute force is too slow, then most likely we\'ll use dynamic programming.\n  Here are the steps the solving a counting problem with dynamic programming:\n  * Identify an overlapping subproblem, which will be counting the number of ways on a smaller problem\n  * Identify how to use answers from sub-problems to solve a bigger sub-problem or the main problem (i.e. transition between states)\n  * Identify the base cases and the answers to them\n  * Check for any edge cases (i.e. where the count is 0)\n\n  For a breakdown of DP patterns, check out this video (1.5h):\n\n  <div class="responsive-iframe">\n    <iframe src="https://www.youtube.com/embed/9k31KcQmS_U?si=nEC14fKchw1LZY1w&amp;start=1341" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>\n  </div>\n\n  ',graph:"\n  ## [Graph Algorithms](https://algo.monster/problems/graph_intro)\n  Problems can present graph-related challenges in three distinct ways:\n\n  1. **Explicit Graph Mention:**\n\n  * The [problem statement](/liteproblems/network-delay-time) may directly specify\n      that you have a graph with nodes and edges.\n\n  2. **Matrix Representation:**\n\n  * The graph might be represented as a matrix.\n  * Indications include statements referring to adjacent cells connecting. For instance, a problem might state,\n      \"From each cell, you can move left, right, up, or down.\" See this [example](/liteproblems/329).\n\n  3. **Graph Construction Required:**\n\n      * Sometimes, you need to devise the graph based on the problem's context.\n      * Problems that address states and their relationships can be visualized with states as nodes and relationships as edges.\n      * Here, it's crucial to identify:\n        * The type of graph (e.g., directed/undirected, weighted/unweighted, tree, or any specific attributes).\n        * The specific problem aspect (e.g., shortest path, connectivity).\n\n      **Examples:**\n\n      * Problem 1: [Evaluate Division](/liteproblems/399)\n        * Variables are the states or nodes.\n        * Equations denote directed, weighted edges showing quotients between two variables.\n        * Queries seek the product path between two nodes.\n\n      * Problem 2: [Detonate the Maximum Bombs](/liteproblems/2101)\n        * Bombs symbolize states or nodes.\n        * A directed, unweighted edge exists from bomb `a` to bomb `b` if bomb `b` is within `a`'s range.\n        * The objective is to determine the maximum nodes reachable from a specific node.\n\n      * Problem 3: [Loud and Rich](/liteproblems/851)\n        * Individuals represent the states or nodes.\n        * \"richer\" outlines the directed edges, showing person `a` is wealthier than person `b`.\n        * The graph is directed and doesn't contain any cycles.\n        * The task is, for each node `x`, to identify the minimum `quiet[y]` value where `x` is reachable from node `y`.\n  ",tree:'\n\n  ## [Trees](https://algo.monster/problems/tree_intro)\n  The simplest and most common way to determine if a problem deals with trees is if the problem directly refers to a "tree", "root" or a\n  "leaf".\n\n  Examples:\n  * [Maximum Depth of Binary Tree](/liteproblems/104)\n    * "Given the **root of a binary tree**, return its maximum depth"\n  * [Minimum Height Trees](/liteproblems/310)\n    * "Given a **tree** of `n` nodes labelled from `0` to `n - 1`"\n  * [Subtree of Another Tree](/liteproblems/572)\n    * "Given the **roots of two binary trees** `root` and `subRoot`"\n\n  We should also take not of some properties of trees. If a problem mentions a graph (not explicity a tree),\n  we can identify some relation to trees of some properties of trees are mentioned. For example, the fact that trees\n  have `n - 1` nodes if the number of nodes in that tree is `n` or the fact that they don\'t have cycles.\n\n  ',"tree-dfs":"\n\n  ## [DFS](https://algo.monster/problems/dfs_on_trees_intro)\n  When tackling tree problems, Depth First Search (DFS) often takes the spotlight due to its natural alignment\n  with tree hierarchies, space efficiency, and ease of recursion. While Breadth First Search (BFS) shines in\n  scenarios like finding the shortest path in unweighted trees or level-order traversals, DFS stands out for\n  depth-related tasks, path-oriented challenges, and its adaptability to various traversal techniques.\n\n  [This article](https://algo.monster/problems/dfs_on_trees_intro) goes more into depth about dfs on trees.\n  ","directed-graph":'\n  ## Directed Acyclic Graphs\n\n  When diving into graph problems, one of the first decisions you have to make is determining\n  the type of graph you\'re dealing with. Among the many distinctions, one of the most fundamental is whether the\n  graph is directed or undirected.\n\n  How can you determine if a problem is centered around [directed graphs](/problems/graph_intro)?\n\n  * **Explicit Mentions:** Start by skimming the problem statement. If words like "directed" or "one-way" are present,\n    they\'re clear indicators of a directed graph.\n  * **Edge Descriptions:** Problems might describe scenarios where one node "points to" or "leads to" another.\n    This directional language is a classic hallmark of directed graphs.\n  * **No Mutuality in Relationships:** If the relationships between nodes aren\'t mutual \u2013 for instance, if Node `A` is\n  related to Node `B`, but Node `B` isn\'t necessarily related to Node `A` \u2013 you\'re likely dealing with directed edges.\n\n  * Examples:\n    * [Course Schedule](/problems/course_schedule): The nature of prerequisites inherently\n      indicates direction. If course `A` is a prerequisite for course `B`, it doesn\'t mean course `B` is\n      a prerequisite for course `A`. The problem\'s relationship isn\'t mutual, indicating a directed graph.\n    * [Network Delay Time](/liteproblems/network-delay-time): The phrase "directed edges" is a\n      direct giveaway. Moreover, the problem specifies source and target nodes for each travel time,\n      reinforcing that the relationships are not mutual.\n\n  ## Recognizing Acyclic Graphs in Problems\n\n  When approaching graph problems, the structure and nature of the graph play pivotal roles. The concept of acyclicity,\n  where a graph doesn\'t have any cycles, is a key structural property. Here\'s how you can determine if a problem\n  is hinging on the acyclic nature of a graph:\n  * **Explicit Mentions:** Some problems may straightforwardly state terms like "Directed Acyclic Graph" or "DAG".\n    This is a direct indicator of the acyclic nature.\n  * **Dependency Chains:** If the problem revolves around a hierarchy or ordering of tasks, where tasks have prerequisites\n    and you cannot have cyclic dependencies, it\'s hinting at acyclicity. Phrases like "before", "after", or "must be\n    completed prior to" are cues.\n  * **Cycle Detection:** If the problem is explicitly about detecting cycles, determining the presence or absence\n    of cycles, or ensuring no cyclic dependencies, then it\'s inherently related to acyclicity.\n\n  **Examples:**\n  * [Course Schedule](/problems/course_schedule)\n    * The dependencies form a directed graph where nodes represent courses and edges represent prerequisites.\n      A valid course schedule exists if and only if the graph has no cycles. If there\'s a cycle, it\'s impossible to\n      complete all courses.\n  * [All Ancestors of a Node in a Directed Acyclic Graph](/liteproblems/2192):\n    * The problem explicitly mentions a directed acyclic graph: You are given a positive integer n representing the\n      number of nodes of a "Directed Acyclic Graph"\n  * [Alien Dictionary](/liteproblems/269)\n    * Each pair of words in the dictionary gives a relative order of characters. These relative orders\n      can be represented as directed edges in a graph. If there\'s a cycle, it means there\'s a contradiction in the ordering,\n      making it impossible to determine the language\'s character order.\n\n  ',"shortest-path-weighted":'\n  ## Weighted Graphs\n\n  One of the prevalent categories within graph theory is the shortest path problem. The next pivotal decision is\n  identifying whether the graph is weighted or not. This distinction profoundly influences the problem-solving approach.\n\n  The most immediate clue is when the problem provides a distinct weight, cost, or distance\n  for each edge or when the problem directly states the graph is weighted. An unweighted graph will have all edge weights\n  be the same, usually `1`. If the edge weights can vary based on problem constraints, the graph is most likely weighted.\n\n  **Examples:**\n  * [Network Delay Time](/liteproblems/743)\n    * Evidence: "where `w_i` is the time it takes for a signal to travel from source to target", `0 <= w_i <= 100`\n  * [Path with Maximum Probability](/liteproblems/1514)\n    * Evidence: " undirected edge connecting the nodes `a` and `b` with a probability of success of traversing\n    that edge `succProb[i]`", `0 <= succProb[i] <= 1`\n  * [Minimum Cost to Reach Destination in Time](/liteproblems/1928)\n    * Evidence: "`edges[i] = [x_i, y_i, time_i]` denotes a road between cities `x_i` and `y_i` that takes `time_i`\n     minutes to travel."\n  ',"shortest-path-dijkstra":"\n  ## Dijkstra's Algorithm\n\n  Navigating the complex realm of graph theory, we often encounter the challenge of finding the shortest path in a weighted graph.\n  In this scenario, it's crucial to consider Dijkstra's Algorithm - a powerful tool tailored for this precise problem.\n\n  Dijkstra's Algorithm operates as follows: starting from a selected vertex, it determines the shortest path\n  to all other vertices. If no path is available, it acknowledges the absence.\n\n  Delve deeper into Dijkstra's Algorithm with [this article](https://algo.monster/problems/dijkstra_intro).\n  ","shortest-path-bfs":"\n  ## Breadth First Search (BFS)\n\n  When dealing with shortest path problems in unweighted graphs, where all edges have the same weight, Breadth-First Search (BFS)\n  stands out as it ensures an efficient and reliable means of pinpointing the shortest path.\n\n  BFS operates as follows: starting from a designated vertex, it determines the shortest path to all other vertices,\n  also marking any vertex as unreachable if no path exists to it.\n\n  You can learn about BFS in [this article](https://algo.monster/problems/bfs_intro).\n  ",connectivity:'\n  ## Connectivity Problems\n\n  Connectivity in graph problems refers to scenarios where the relatedness of nodes plays a central role.\n  Recognizing when a graph challenge is rooted in "connectivity" can guide you towards the most effective solution.\n  So, how do you discern these types of problems?\n\n  Watch for these indicative signs:\n  * **Distinctive Terminology:** Terms such as "connected", "component", "island", and "group" often signal that a\n    problem\'s focus is on connectivity.\n  * **Uniting or Merging**: Problems discussing connecting or merging nodes, like linking towns through\n    roads, usually center on connectivity.\n  * **Traversal Queries:** Queries about traversing a structure from one point to all others, without retracing\n    steps, also point towards connectivity.\n\n  **Examples:**\n  * [Accounts Merge](/problems/dsu_account_merge): Visualize each account as a node. Accounts\n    sharing an email are interconnected. Essentially, the task involves identifying connected components,\n    where each component represents a distinct individual.\n  * [Redundant Connection](/liteproblems/684): Here, the aim is to spot an edge,\n    such that removing this edge should yield a connected graph devoid of cycles, referenced as a tree in\n    the problem statement.\n  * [Number of Operations to Make Network Connected](/liteproblems/1319):\n    The problem statement directly mentions the objective of making the "entire network connected". The keyword "connected" in the\n    statement also suggests the problem is a connectivity problem.\n  ',"connectivity-dsu":'\n  ## Disjoint Set Union\n\n\n  Known alternatively as Union-Find, Disjoint Set Union (DSU) stands as a specialized data structure, purpose-built\n  for efficiently addressing connectivity queries within an undirected graph. When navigating connectivity problem,\n  DSU often emerges as a top choice due to its ability in dynamically categorizing elements into separate sets\n  and its ability to efficiently verify if two elements coexist within the same set.\n\n  DSU operations:\n  * Union Operation:  Merges two distinct sets into one cohesive unit. When two nodes are from different sets,\n    the Union operation integrates them, rendering them members of an identical group.\n  * Find Operation: Pinpoints the specific set to which an element is affiliated. This task is achieved\n    by following a path up to the set\'s "representative" or "leader."\n\n  While traditional methods like BFS and DFS can also cater to connectivity inquiries, DSU rises above with\n  its heightened efficiency. DSU offers more efficient connectivity queries and can handle dynamic\n  scenarios where edges are added in the graph.\n\n  A more in depth explanation and tutorial of DSU can be found [here](https://algo.monster/problems/dsu_intro).\n  ',"directed-graph-topo":'\n  ## [Topological Sort](/problems/topo_intro)\n\n  Topological sort is a crucial algorithm for directed acyclic graphs, often abbreviated as DAGs. By definition,\n  a DAG is a graph characterized by its directed edges and absence of cycles, ensuring that no sequence of edges\n  loops back to a repeating vertex.\n\n  A topological sort offers a linear ordering of the vertices so that if there\'s a directed edge from vertex `U` to\n  vertex `V`, `U` always precedes `V` in the order. This ensures that all "prerequisites" come before the\n  dependent node.\n\n  [This article](https://algo.monster/problems/topo_intro) provides a deeper dive into topological sorting.\n  ',"shortest-path":'\n  ## Identifying Shortest Path Problems\n\n  In graph-related questions, determining the shortest or most optimal path between nodes is a common theme.\n  However, not every problem explicitly states, ["find the shortest path"](/problems/shortest_path_unweight). Often, cues embedded in the problem\'s\n  phrasing signal a need for a shortest path solution.\n\n  Here are telltale signs:\n\n  * **Distance or Minimum Steps:** Problems might inquire about the least number of steps, transformations, or moves\n    to attain a specific objective.\n  * **Seeking Optimal Solutions:** Some problems revolve around finding the fastest, least costly, or most efficient\n    method to achieve an outcome within the graph\'s structure.\n  * **Constrained Traversals:** Occasionally, the traversal of a graph demands set conditions, such as\n    avoiding obstacles or using specific paths a limited number of times.\n\n  **Examples:**\n  * [Network Delay Time](/liteproblems/743): At its core, this problem seeks the\n    longest of the shortest paths from a designated source node to all other nodes within the graph.\n  * [Shortest Path in Binary Matrix](/liteproblems/1091): Explicitly,\n    the problem asks for the shortest path, evident from the phrase "return the length of the shortest\n    clear path in the matrix."\n  * [Cheapest Flight Within K Stops](/liteproblems/787): Related to\n    optimality, this challenge prompts for the "cheapest price from `src` to `dst`, permitting at most `k` stops."\n\n  ',"graph-smallcontraints":'\n  ## Identifying Brute Force [DFS](https://algo.monster/problems/dfs_on_trees_intro)/[Backtracking](https://algo.monster/problems/backtracking)\n\n  Brute force solutions, particularly in graph problems, involve comprehensively exploring all paths or configurations\n  to derive a solution. This strategy is essentially an unrefined exploration, and in some scenarios, particularly\n  with small constraints, it becomes the go-to approach.\n\n  When diving into graph problems, how can you pinpoint when a brute force method is required?\n\n  Look out for these key indicators:\n  1. **Vast Search Space with No Direct Optimizations**\n\n      If the problem sets up an expansive search space and doesn\'t offer clear-cut optimizations, consider\n      brute force as an opening strategy.\n\n  2. **Asks for All Possible Solutions**\n\n      When the problem statement uses terms like "find all possible paths" or "determine all configurations,"\n      it\'s often hinting towards an exhaustive, brute force approach as a foundation.\n\n  3. **Small Graph Constraints**:\n    If the graph\'s constraints are limited \u2014 for instance, if there are up to 10^2 nodes \u2014 a brute force method is\n    likely workable within computational time limits.\n\n  Brute force in graph problems often entails trying every possible path or configuration to obtain a solution.\n  It\'s a naive way of exploring all possibilities without employing any optimizations. A typical brute force\n  strategy on graphs might involve running a DFS or BFS from every node or for every possible combination of nodes.\n\n  **Examples:**\n\n  * [Word Search](/liteproblems/79)\n    * **Constraints:**`1 <= m, n <= 6`, `1 <= word.length <= 15`\n  * [All Paths From Source to target](/liteproblems/797)\n    * "Find all possible paths from node `0` to node `n - 1` and return them in any order."\n    * **Constraints:**`2 <= n <= 15`\n  * [Couple Holding Hands](/liteproblems/765)\n    * **Constraints:** `2 <= n <= 30`\n\n  ',"graph-smallcontraints-dfs":"\n  ## [DFS](https://algo.monster/problems/dfs_on_trees_intro)\n\n  In graph problems with small constraints, Depth-First Search (DFS) and backtracking shine as invaluable techniques.\n  They excel by exhaustively diving into each potential solution path until reaching a resolution or a dead-end.\n  DFS systematically begins from a source node, delving deep along each branch and only backtracks when necessary.\n  This depth-driven approach is especially suited for problems where traversing numerous paths within a graph\n  is essential.\n\n  For a comprehensive explanation of dfs, refer to the tutorial [here](https://algo.monster/problems/dfs_intro).\n  ","graph-smallcontraints-bfs":"\n  ## [BFS](https://algo.monster/problems/bfs_intro)\n\n  In general graph theory problems, both Breadth First Search (BFS) and Depth First Search (DFS) are fundamental\n  algorithms. BFS is especially favored for detecting shortest paths and assessing connectivity, whereas DFS excels\n  in other areas but doesn't always provide the shortest path. When confronting unconventional graph problems,\n  considering the application of BFS or DFS often illuminates a path to a solution. Despite their simplicity,\n  these algorithms address a vast array of graph-related challenges.\n\n  For a detailed understanding, refer to the BFS tutorial [here](https://algo.monster/problems/bfs_intro) and the DFS\n  tutorial [here](https://algo.monster/problems/dfs_intro).\n  ","parse-symbols":"\n  ## Symbol Parsing Problems\n\n  Problems that involve parsing or evaluating expressions with symbols like parentheses, operators, or other special characters often require a stack-based approach. Look for these indicators:\n\n  * Need to match opening/closing symbols (like parentheses, brackets, braces)\n  * Need to evaluate mathematical expressions\n  * Need to validate syntax or expression correctness\n  * Need to process nested structures like an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)\n\n  Examples:\n  * [Valid Parentheses](/liteproblems/20)\n    * \"Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\"\n  * [Basic Calculator](/liteproblems/224)\n    * \"Implement a basic calculator to evaluate a simple expression string.\"\n  ","parse-symbols-stack":"\n  ## [Stack](https://algo.monster/problems/stack_intro)\n\n  A stack is a Last-In-First-Out (LIFO) data structure that's particularly useful for parsing because:\n  * It naturally handles nested structures by keeping track of the most recently seen symbols\n  * The LIFO property matches how nested expressions work - the most recently opened parenthesis must be closed first\n  * It can maintain state/context as you process symbols one by one\n  * It allows you to \"backtrack\" by popping elements when you need to resolve or close a nested structure\n\n  For example, when parsing \"(())\", the stack operations would be:\n  1. Push '(' - stack: ['(']\n  2. Push '(' - stack: ['(', '(']\n  3. Pop '(' and match with ')' - stack: ['(']\n  4. Pop '(' and match with ')' - stack: []\n  Empty stack at end means valid expression!\n\n  Examples of stack usage:\n  * [Valid Parentheses](/liteproblems/20): Use stack to match opening and closing brackets\n  * [Basic Calculator](/liteproblems/224): Use stack to handle nested expressions and operator precedence\n  * [Remove All Adjacent Duplicates In String](/liteproblems/1047): Use stack to track and remove adjacent duplicates\n  "},x=function(e){var t=new Map;return e.forEach((function(e){t.set(e.target,e.source)})),t}(v),S='## What is it? \n The AlgoMonster flowchart, developed by ex-Googlers and competitive programmers, is based on solving thousands of problems and identifying common patterns. Its purpose is to provide a structured method for solving coding problems. \n ## How to use it?\n Internal nodes (diamonds) are decisions based on problem descriptions. Leaf nodes (purple boxes) are the algorithms you would need to solve the problem. Traverse the tree from the root until you reach a leaf node, and that is the algorithm you need to solve the problem. Select a node to see more explanations, or watch the video below for a walkthrough.  <div className="responsive-iframe"> <iframe src="https://www.youtube.com/embed/s5gWz9Fa1yo?start=56" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" ></iframe> </div> \n ## Do I memorize this? \n This is a common question, and the answer is NO. The flowchart is a tool and a reference to help you understand the patterns. As you work through problems using the flowchart, you will naturally get better at recognizing the patterns. "Education is not the learning of facts, but the training of the mind to think." Practice and you shall learn. No memorization needed! \n  ## What else is there? \n The flowchart is just one tool; there are many other tools and techniques to help you solve problems. \n - If you like quick references, check out the [runtime to algo cheatsheet](/problems/runtime_summary).\n - If you like to get an overview of how patterns can help you learn and prepare for interviews faster, check out the [pattern-based learning](/problems/stats).\n - If you want to jump right in to start learning a pattern, check out the [binary search intro](/problems/binary_search_intro).\n ## AlgoMonster Pro \n Finally, may I suggest checking out the limited time offer on [AlgoMonster Pro](/subscribe) to get everything you need to master the interview and land your dream job.';function _(e){var t=e.setSelectedNodeDescription,n=e.initialViewportX,m=e.initialViewportY,h=e.panOnDrag,d=void 0===h||h,p=e.zoomOnDoubleClick,u=void 0===p||p,b={x:null!==n&&void 0!==n?n:100,y:null!==m&&void 0!==m?m:50,zoom:.5};(0,c.useEffect)((function(){return t(S)}),[]);var g=(0,s.Z)((0,l.Rr)(w),3),_=g[0],T=g[1],q=g[2],I=(0,s.Z)((0,l.ll)(v),3),D=I[0],j=I[1],F=I[2];return(0,a.jsx)(l.x$,{defaultViewport:b,style:{flexGrow:1,minHeight:"100%",color:"black"},nodes:_,edges:D,onNodesChange:q,onEdgesChange:F,elementsSelectable:!0,nodesDraggable:!0,zoomOnDoubleClick:u,panOnDrag:d,attributionPosition:"top-right",proOptions:{hideAttribution:!0},onNodeClick:function(e,n){t(k[n.id]+"\n Flowchart video walkthrough: https://youtu.be/s5gWz9Fa1yo?t=313");for(var s=new Set,a=new Set,l=n.id;"graph"!=l;){var c=x.get(l);if(console.log("parent node: "+c),!c){console.log("wtf");break}s.add(c),a.add(l),l=c}var m=(0,r.Z)(v);m.forEach((function(e){return s.has(e.source)&&a.has(e.target)?e.animated=!0:e.animated=!1,e})),j(m),T(_.map((function(e){return e.id===n.id?(0,i.Z)((0,o.Z)({},e),{data:(0,i.Z)((0,o.Z)({},e.data),{isSelected:!0})}):(0,i.Z)((0,o.Z)({},e),{data:(0,i.Z)((0,o.Z)({},e.data),{isSelected:!1})})})))},onPaneClick:function(){return t(S)},edgeTypes:f,nodeTypes:y})}},78650:function(e,t,n){"use strict";n.d(t,{Z:function(){return _}});var o=n(26042),i=n(69396),s=n(99534),r=n(85893),a=n(5454),l=n(41664),c=n.n(l),m=n(29078),h=n(78788),d=n(994),p=n.n(d),u=n(27364),b=n(14769),g=n(30399),f=n(17819),y=(n(97604),n(17754)),w=n(67418);function v(e){var t=e.folder,n=e.num,o=Array.from({length:n},(function(e,n){return"".concat(t,"/").concat(n+1,".svg")}));return(0,r.jsx)(w.Z,{images:o,minerSideButtons:!0})}var k=n(67294),x=function(e){var t=e.href,n=e.children,o=e.openLinksInNewTab;return(0,r.jsx)(c(),{href:t||"/",children:(0,r.jsx)("a",{target:o?"_blank":"_self",rel:o?"noopener noreferrer":"",children:n})})},S=function(e){var t=e.children;return(0,r.jsx)(m.Z,{striped:!0,bordered:!0,responsive:!0,children:t})},_=function(e){var t=e.content,n=e.openLinksInNewTab,l=void 0!==n&&n,c=e.className,m=(0,y.m0)().darkModeFlag;return(0,r.jsx)(h.D,{className:"".concat(p().markdown," ").concat(null!==c&&void 0!==c?c:""),children:t,rehypePlugins:[u.Z,f.Z],remarkPlugins:[b.Z,g.Z],components:{p:function(e){e.node;var t=e.children,n=(0,s.Z)(e,["node","children"]);return k.Children.toArray(t).some((function(e){var t;return k.isValidElement(e)&&"slide-show"===(null===(t=e.type)||void 0===t?void 0:t.name)}))?(0,r.jsx)(r.Fragment,{children:t}):(0,r.jsx)("p",(0,i.Z)((0,o.Z)({className:p().p},n),{children:t}))},code:function(e){return(0,r.jsx)(a.Z,(0,i.Z)((0,o.Z)({},e),{darkMode:m,showLineNumbers:!1}))},a:function(e){return(0,r.jsx)(x,(0,i.Z)((0,o.Z)({},e),{openLinksInNewTab:l}))},table:S,"slide-show":function(e){var t=e.folder,n=e.num;return(0,r.jsx)(v,{folder:t,num:n})}}})}},67418:function(e,t,n){"use strict";var o=n(85893),i=n(67294),s=n(34051),r=n(31555),a=n(97279),l=n(35005),c=n(48976),m=n.n(c);t.Z=function(e){var t=function(){var t=(0,i.useState)(!1),n=t[0],c=t[1];return(0,o.jsxs)(s.Z,{className:m().slides+(e.minerSideButtons?" "+m().minerSideRow:""),children:[(0,o.jsx)(r.Z,{className:"text-center col-12",children:(0,o.jsx)(a.Z,{className:e.minerSideButtons?m().minerSideButtons:"",indicators:!0,interval:n?1500:null,slide:!1,fade:!0,children:e.images.map((function(e){return(0,o.jsx)(a.Z.Item,{children:(0,o.jsx)("img",{className:"d-block w-100",src:e,alt:"First slide"})},e)}))})}),(0,o.jsx)(r.Z,{className:"text-center col-12 tw-mt-4",children:(0,o.jsx)(l.Z,{variant:"outline-secondary",onClick:function(){c(!n)},children:n?"\u275a\u275a":"\u25b6"})})]})};return(0,o.jsx)(t,{})}},85522:function(e){e.exports={codeBlock:"CodeBlock_codeBlock__96Xj8"}},994:function(e){e.exports={markdown:"MarkdownRenderer_markdown__OXPld"}},48976:function(e){e.exports={slides:"Slides_slides__uFnwu",minerSideButtons:"Slides_minerSideButtons__f_yND",minerSideRow:"Slides_minerSideRow__fxlXc"}},54722:function(){},53250:function(e,t,n){"use strict";var o=n(67294);var i="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},s=o.useState,r=o.useEffect,a=o.useLayoutEffect,l=o.useDebugValue;function c(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!i(e,n)}catch(o){return!0}}var m="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?function(e,t){return t()}:function(e,t){var n=t(),o=s({inst:{value:n,getSnapshot:t}}),i=o[0].inst,m=o[1];return a((function(){i.value=n,i.getSnapshot=t,c(i)&&m({inst:i})}),[e,n,t]),r((function(){return c(i)&&m({inst:i}),e((function(){c(i)&&m({inst:i})}))}),[e]),l(n),n};t.useSyncExternalStore=void 0!==o.useSyncExternalStore?o.useSyncExternalStore:m},50139:function(e,t,n){"use strict";var o=n(67294),i=n(61688);var s="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t},r=i.useSyncExternalStore,a=o.useRef,l=o.useEffect,c=o.useMemo,m=o.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,o,i){var h=a(null);if(null===h.current){var d={hasValue:!1,value:null};h.current=d}else d=h.current;h=c((function(){function e(e){if(!l){if(l=!0,r=e,e=o(e),void 0!==i&&d.hasValue){var t=d.value;if(i(t,e))return a=t}return a=e}if(t=a,s(r,e))return t;var n=o(e);return void 0!==i&&i(t,n)?t:(r=e,a=n)}var r,a,l=!1,c=void 0===n?null:n;return[function(){return e(t())},null===c?void 0:function(){return e(c())}]}),[t,n,o,i]);var p=r(e,h[0],h[1]);return l((function(){d.hasValue=!0,d.value=p}),[p]),m(p),p}},61688:function(e,t,n){"use strict";e.exports=n(53250)},52798:function(e,t,n){"use strict";e.exports=n(50139)},83840:function(e,t,n){"use strict";function o(e){if("string"===typeof e||"number"===typeof e)return""+e;let t="";if(Array.isArray(e))for(let n,i=0;i<e.length;i++)""!==(n=o(e[i]))&&(t+=(t&&" ")+n);else for(let n in e)e[n]&&(t+=(t&&" ")+n);return t}n.d(t,{Z:function(){return o}})},62487:function(e,t,n){"use strict";n.d(t,{Z:function(){return u}});var o=n(96057),i=n(23838),s=n(46939),r=n(22718),a=n(79611),l=e=>()=>e;function c(e,{sourceEvent:t,subject:n,target:o,identifier:i,active:s,x:r,y:a,dx:l,dy:c,dispatch:m}){Object.defineProperties(this,{type:{value:e,enumerable:!0,configurable:!0},sourceEvent:{value:t,enumerable:!0,configurable:!0},subject:{value:n,enumerable:!0,configurable:!0},target:{value:o,enumerable:!0,configurable:!0},identifier:{value:i,enumerable:!0,configurable:!0},active:{value:s,enumerable:!0,configurable:!0},x:{value:r,enumerable:!0,configurable:!0},y:{value:a,enumerable:!0,configurable:!0},dx:{value:l,enumerable:!0,configurable:!0},dy:{value:c,enumerable:!0,configurable:!0},_:{value:m}})}function m(e){return!e.ctrlKey&&!e.button}function h(){return this.parentNode}function d(e,t){return null==t?{x:e.x,y:e.y}:t}function p(){return navigator.maxTouchPoints||"ontouchstart"in this}function u(){var e,t,n,u,b=m,g=h,f=d,y=p,w={},v=(0,o.Z)("start","drag","end"),k=0,x=0;function S(e){e.on("mousedown.drag",_).filter(y).on("touchstart.drag",I).on("touchmove.drag",D,a.Q7).on("touchend.drag touchcancel.drag",j).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function _(o,s){if(!u&&b.call(this,o,s)){var l=F(this,g.call(this,o,s),o,s,"mouse");l&&((0,i.Z)(o.view).on("mousemove.drag",T,a.Dd).on("mouseup.drag",q,a.Dd),(0,r.Z)(o.view),(0,a.rG)(o),n=!1,e=o.clientX,t=o.clientY,l("start",o))}}function T(o){if((0,a.ZP)(o),!n){var i=o.clientX-e,s=o.clientY-t;n=i*i+s*s>x}w.mouse("drag",o)}function q(e){(0,i.Z)(e.view).on("mousemove.drag mouseup.drag",null),(0,r.D)(e.view,n),(0,a.ZP)(e),w.mouse("end",e)}function I(e,t){if(b.call(this,e,t)){var n,o,i=e.changedTouches,s=g.call(this,e,t),r=i.length;for(n=0;n<r;++n)(o=F(this,s,e,t,i[n].identifier,i[n]))&&((0,a.rG)(e),o("start",e,i[n]))}}function D(e){var t,n,o=e.changedTouches,i=o.length;for(t=0;t<i;++t)(n=w[o[t].identifier])&&((0,a.ZP)(e),n("drag",e,o[t]))}function j(e){var t,n,o=e.changedTouches,i=o.length;for(u&&clearTimeout(u),u=setTimeout((function(){u=null}),500),t=0;t<i;++t)(n=w[o[t].identifier])&&((0,a.rG)(e),n("end",e,o[t]))}function F(e,t,n,o,i,r){var a,l,m,h=v.copy(),d=(0,s.Z)(r||n,t);if(null!=(m=f.call(e,new c("beforestart",{sourceEvent:n,target:S,identifier:i,active:k,x:d[0],y:d[1],dx:0,dy:0,dispatch:h}),o)))return a=m.x-d[0]||0,l=m.y-d[1]||0,function n(r,p,u){var b,g=d;switch(r){case"start":w[i]=n,b=k++;break;case"end":delete w[i],--k;case"drag":d=(0,s.Z)(u||p,t),b=k}h.call(r,e,new c(r,{sourceEvent:p,subject:m,target:S,identifier:i,active:b,x:d[0]+a,y:d[1]+l,dx:d[0]-g[0],dy:d[1]-g[1],dispatch:h}),o)}}return S.filter=function(e){return arguments.length?(b="function"===typeof e?e:l(!!e),S):b},S.container=function(e){return arguments.length?(g="function"===typeof e?e:l(e),S):g},S.subject=function(e){return arguments.length?(f="function"===typeof e?e:l(e),S):f},S.touchable=function(e){return arguments.length?(y="function"===typeof e?e:l(!!e),S):y},S.on=function(){var e=v.on.apply(v,arguments);return e===v?S:e},S.clickDistance=function(e){return arguments.length?(x=(e=+e)*e,S):Math.sqrt(x)},S}c.prototype.on=function(){var e=this._.on.apply(this._,arguments);return e===this._?this:e}},73445:function(e,t,n){"use strict";n.d(t,{oR:function(){return r}});var o=n(67294),i=n(52798);const{useSyncExternalStoreWithSelector:s}=i;function r(e,t=e.getState,n){const i=s(e.subscribe,e.getState,e.getServerState||e.getState,t,n);return(0,o.useDebugValue)(i),i}},76248:function(e,t,n){"use strict";function o(e,t){if(Object.is(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;if(e instanceof Map&&t instanceof Map){if(e.size!==t.size)return!1;for(const[n,o]of e)if(!Object.is(o,t.get(n)))return!1;return!0}if(e instanceof Set&&t instanceof Set){if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0}const n=Object.keys(e);if(n.length!==Object.keys(t).length)return!1;for(let o=0;o<n.length;o++)if(!Object.prototype.hasOwnProperty.call(t,n[o])||!Object.is(e[n[o]],t[n[o]]))return!1;return!0}n.d(t,{X:function(){return o}})},43973:function(e,t,n){"use strict";n.d(t,{M:function(){return i}});const o=e=>{let t;const n=new Set,o=(e,o)=>{const i="function"===typeof e?e(t):e;if(!Object.is(i,t)){const e=t;t=(null!=o?o:"object"!==typeof i)?i:Object.assign({},t,i),n.forEach((n=>n(t,e)))}},i=()=>t,s={setState:o,getState:i,subscribe:e=>(n.add(e),()=>n.delete(e)),destroy:()=>{console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}};return t=e(o,i,s),s},i=e=>e?o(e):o}}]);