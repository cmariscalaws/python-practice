!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).formbricks=t()}(this,(function(){"use strict";var e=Object.defineProperty,t=(t,n,r)=>((t,n,r)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r)(t,"symbol"!=typeof n?n+"":n,r);const n=class e{constructor(){t(this,"logLevel","error")}static getInstance(){return e.instance||(e.instance=new e),e.instance}configure(e){void 0!==e.logLevel&&(this.logLevel=e.logLevel)}logger(e,t){if("debug"===t&&"debug"!==this.logLevel)return;const n=`ðŸ§± Formbricks - ${(new Date).toISOString()} [${t.toUpperCase()}] - ${e}`;"error"===t?console.error(n):console.log(n)}debug(e){this.logger(e,"debug")}error(e){this.logger(e,"error")}resetInstance(){e.instance=void 0}};t(n,"instance");let r=n;const s=e=>({ok:!0,data:e}),a=e=>({ok:!1,error:e});let o=!1;const i=(e,t)=>{const n=Math.abs(t.getTime()-e.getTime());return Math.floor(n/864e5)},d=e=>(...t)=>{try{return{ok:!0,data:e(...t)}}catch(n){return{ok:!1,error:n}}},c=e=>async(...t)=>{try{return{ok:!0,data:await e(...t)}}catch(n){return{ok:!1,error:n}}},u=(e,t)=>{const{project:n,surveys:r}=e.data,{displays:s,responses:a,lastDisplayAt:o,segments:d,userId:c}=t.data;let u=r.filter((e=>{switch(e.displayOption){case"respondMultiple":return!0;case"displayOnce":return 0===s.filter((t=>t.surveyId===e.id)).length;case"displayMultiple":return 0===a.filter((t=>t===e.id)).length;case"displaySome":return null===e.displayLimit||!a.filter((t=>t===e.id)).length&&s.filter((t=>t.surveyId===e.id)).length<e.displayLimit;default:throw Error("Invalid displayOption")}}));return u=u.filter((e=>!o||(null!==e.recontactDays?i(new Date,new Date(o))>=e.recontactDays:!n.recontactDays||i(new Date,new Date(o))>=n.recontactDays))),c?d.length?u.filter((e=>{var t;return(null==(t=e.segment)?void 0:t.id)&&d.includes(e.segment.id)})):[]:u.filter((e=>{var t;return 0===((null==(t=e.segment)?void 0:t.filters.length)??0)}))},l=(e,t)=>{var n;return e.styling.allowStyleOverwrite&&(null==(n=t.styling)?void 0:n.overwriteThemeStyling)?t.styling:e.styling},g=e=>Math.floor(1e4*(()=>{const e=new Uint32Array(1);return crypto.getRandomValues(e),e[0]/2**32})())/100<=e,p=e=>new Date>=e,m=e=>{if(0===e.length)return!0;const t=window.location.href;return e.some((e=>((e,t,n)=>{switch(n){case"exactMatch":return e===t;case"contains":return e.includes(t);case"startsWith":return e.startsWith(t);case"endsWith":return e.endsWith(t);case"notMatch":return e!==t;case"notContains":return!e.includes(t);default:return!1}})(t,e.value,e.rule)))},f=(e,t)=>{var n;if("click"!==(null==(n=t.noCodeConfig)?void 0:n.type))return!1;const r=t.noCodeConfig.elementSelector.innerHtml,s=t.noCodeConfig.elementSelector.cssSelector,a=t.noCodeConfig.urlFilters;if(!r&&!s)return!1;if(r&&e.innerHTML!==r)return!1;if(s){const t=s.split(/(?=[.#])/).map((e=>e.trim()));for(const n of t)if(!e.matches(n))return!1}return!!m(a)},v=()=>window.location.search.includes("formbricksDebug=true"),h="formbricks-js",y="formbricks-app-container",w="formbricks-recaptcha-script",b=class e{constructor(){t(this,"config",null);const e=this.loadFromLocalStorage();e.ok&&(this.config=e.data)}static getInstance(){return e.instance??(e.instance=new e),e.instance}update(e){var t,n;this.config={...this.config,...e,status:{value:(null==(t=e.status)?void 0:t.value)??"success",expiresAt:(null==(n=e.status)?void 0:n.expiresAt)??null}},this.saveToStorage()}get(){if(!this.config)throw new Error("config is null, maybe the init function was not called?");return this.config}loadFromLocalStorage(){if("undefined"!=typeof window){const e=localStorage.getItem(h);if(e){const t=JSON.parse(e);return s(t)}}return a(new Error("No or invalid config in local storage"))}saveToStorage(){return d((()=>{localStorage.setItem(h,JSON.stringify(this.config))}))()}resetConfig(){return this.config=null,d((()=>{localStorage.removeItem(h)}))()}};t(b,"instance",null);let I=b;const k=async(e,t,n,r,o=!1)=>{const i=new URL(e+t),d=r?JSON.stringify(r):void 0,u=await c(fetch)(i.toString(),{method:n,headers:{"Content-Type":"application/json",...o&&{"Cache-Control":"no-cache"}},body:d});if(!u.ok)return a({code:"network_error",status:500,message:"Something went wrong"});const l=u.data,g=await l.json();if(!l.ok){const e=g;return a({code:"forbidden"===e.code?"forbidden":"network_error",status:l.status,message:e.message||"Something went wrong",url:i,...Object.keys(e.details??{}).length>0&&{details:e.details}})}return s(g.data)};class U{constructor({appUrl:e,environmentId:n,isDebug:r=!1}){t(this,"appUrl"),t(this,"environmentId"),t(this,"isDebug"),this.appUrl=e,this.environmentId=n,this.isDebug=r}async createOrUpdateUser(e){const t={};for(const n in e.attributes)t[n]=String(e.attributes[n]);return k(this.appUrl,`/api/v2/client/${this.environmentId}/user`,"POST",{userId:e.userId,attributes:t},this.isDebug)}async getEnvironmentState(){return k(this.appUrl,`/api/v1/client/${this.environmentId}/environment`,"GET",void 0,this.isDebug)}}const S=async({appUrl:e,environmentId:t,updates:n})=>{const r=`${e}/api/v1/client/${t}/user`;try{const o=new U({appUrl:e,environmentId:t,isDebug:v()}),i=await o.createOrUpdateUser({userId:n.userId,attributes:n.attributes});return i.ok?s(i.data):a({code:i.error.code,status:i.error.status,message:`Error updating user with userId ${n.userId}`,url:new URL(r),responseMessage:i.error.message})}catch(o){const e=o;return a({code:"network_error",message:e.message??"Error fetching the person state",status:500,url:new URL(r),responseMessage:e.message??"Unknown error"})}},C=class e{constructor(){t(this,"updates",null),t(this,"debounceTimeout",null),t(this,"DEBOUNCE_DELAY",500)}static getInstance(){return e.instance??(e.instance=new e),e.instance}updateUserId(e){this.updates?this.updates={...this.updates,userId:e}:this.updates={userId:e,attributes:{}}}updateAttributes(e){var t;const n=I.getInstance(),r=(null==(t=this.updates)?void 0:t.userId)??n.get().user.data.userId??"";this.updates?this.updates={...this.updates,userId:r,attributes:{...this.updates.attributes,...e}}:this.updates={userId:r,attributes:e}}getUpdates(){return this.updates}clearUpdates(){this.updates=null}isEmpty(){return!this.updates}async processUpdates(){const e=r.getInstance();if(this.updates)return this.debounceTimeout&&clearTimeout(this.debounceTimeout),new Promise(((t,n)=>{const s=async()=>{var s,o;try{let n={...this.updates};const i=I.getInstance();if(Object.keys(n).length>0){const t=n.userId??i.get().user.data.userId,d=null==(s=n.attributes)?void 0:s.language;if(!t&&d){i.update({...i.get(),user:{...i.get().user,data:{...i.get().user.data,language:null==(o=n.attributes)?void 0:o.language}}}),e.debug("Updated language successfully");const{language:t,...r}=n.attributes??{};n={...n,attributes:r}}if(Object.keys(n.attributes??{}).length>0&&!t){const t="Formbricks can't set attributes without a userId! Please set a userId first with the setUserId function";e.error(t),this.clearUpdates()}if(t){const s=await(async({updates:e})=>{const t=I.getInstance(),n=r.getInstance(),{appUrl:s,environmentId:o}=t.get(),i=`${s}/api/v1/client/${o}/user`;try{const r=await S({appUrl:s,environmentId:o,updates:e});if(r.ok){const e=r.data.state,s=u(t.get().environment,e),a=r.data.messages;if(a&&a.length>0)for(const t of a)n.debug(`User update message: ${t}`);return t.update({...t.get(),user:{...e},filteredSurveys:s}),{ok:!0,data:void 0}}return a(r.error)}catch(d){if(console.error("error in sending updates: ",d),"code"in d){const e=d;return a({code:e.code,message:e.message,status:e.status,url:new URL(i),responseMessage:e.responseMessage})}return a({code:"network_error",message:"Error sending updates",status:500,url:new URL(i),responseMessage:"Unknown error"})}})({updates:{userId:t,attributes:n.attributes??{}}});s.ok?e.debug("Updates sent successfully"):e.error(`Failed to send updates: ${s.error.responseMessage??s.error.message}`)}}this.clearUpdates(),t()}catch(i){e.error(`Failed to process updates: ${i instanceof Error?i.message:"Unknown error"}`),n(i)}};this.debounceTimeout=setTimeout((()=>{s()}),this.DEBOUNCE_DELAY)}))}};t(C,"instance",null);let A=C;var E=(e=>(e[e.Setup=0]="Setup",e[e.UserAction=1]="UserAction",e[e.GeneralAction=2]="GeneralAction",e))(E||{});const $=class e{constructor(){t(this,"queue",[]),t(this,"running",!1),t(this,"resolvePromise",null),t(this,"commandPromise",null)}static getInstance(){return e.instance??(e.instance=new e),e.instance}add(e,t,n=!0,...r){return new Promise((s=>{try{const a={command:e,type:t,checkSetup:n,commandArgs:r};this.queue.push(a),this.running||(this.commandPromise=new Promise((e=>{this.resolvePromise=e,this.run()}))),s({ok:!0,data:void 0})}catch(a){s({ok:!1,error:a})}}))}async wait(){this.running&&await this.commandPromise}async run(){for(this.running=!0;this.queue.length>0;){const e=this.queue.shift();if(!e)continue;if(e.checkSetup){if(!(r.getInstance().debug("Check if set up"),o?{ok:!0,data:void 0}:a({code:"not_setup",message:"Formbricks is not set up. Call setup() first."})).ok){console.warn("ðŸ§± Formbricks - Setup not complete.");continue}}if(2===e.type){const e=A.getInstance();e.isEmpty()||(console.log("ðŸ§± Formbricks - Waiting for pending updates to complete before executing command"),await e.processUpdates())}const t=async()=>await e.command.apply(null,e.commandArgs),n=await c(t)();n.ok?n.data.ok||console.error("ðŸ§± Formbricks - Global error: ",n.data.error):console.error("ðŸ§± Formbricks - Global error: ",n.error)}this.running=!1,this.resolvePromise&&(this.resolvePromise(),this.resolvePromise=null,this.commandPromise=null)}};t($,"instance",null);let D=$,L=null;const P=async({appUrl:e,environmentId:t})=>{const n=`${e}/api/v1/client/${t}/environment`,r=new U({appUrl:e,environmentId:t,isDebug:v()});try{const e=await r.getEnvironmentState();return e.ok?s(e.data):a({code:e.error.code,status:e.error.status,message:"Error syncing with backend",url:new URL(n),responseMessage:e.error.message})}catch(o){const e=o;return a({code:"network_error",message:e.message,status:500,url:new URL(n),responseMessage:e.responseMessage??"Network error"})}},F=class e{constructor(){t(this,"timeouts",[])}static getInstance(){return e.instance||(e.instance=new e),e.instance}add(e,t){this.timeouts.push({event:e,timeoutId:t})}remove(e){clearTimeout(e),this.timeouts=this.timeouts.filter((t=>t.timeoutId!==e))}clear(){for(const e of this.timeouts)clearTimeout(e.timeoutId);this.timeouts=[]}getTimeouts(){return this.timeouts}};t(F,"instance",null);let T=F;const x=e=>{const t=r.getInstance();return new Promise(((n,r)=>{if(document.getElementById(w))return t.debug("reCAPTCHA script already loaded"),void n();if(!e)return t.debug("reCAPTCHA site key not found"),void r(new Error("reCAPTCHA site key not found"));const s=document.createElement("script");s.id=w,s.src=`https://www.google.com/recaptcha/api.js?render=${e}`,s.async=!0,s.defer=!0,s.onload=()=>{t.debug("reCAPTCHA script loaded successfully"),n()},s.onerror=()=>{t.debug("Error loading reCAPTCHA script:"),r(new Error("Error loading reCAPTCHA script"))},document.head.appendChild(s)}))};let O=!1;const M=e=>{O=e},j=async(e,t,n)=>{const s=r.getInstance();if(e.displayPercentage){if(!g(e.displayPercentage))return void s.debug(`Survey display of "${e.name}" skipped based on displayPercentage.`)}const a=((e,t)=>{const n=r.getInstance(),{enabled:s,fieldIds:a}=e;let o={};if(s){if(a&&t){const e=[];o=Object.keys(t).reduce(((n,r)=>(a.includes(r)?n[r]=t[r]:e.push(r),n)),{}),e.length>0&&n.error(`Unknown hidden fields: ${e.join(", ")}. Please add them to the survey hidden fields.`)}}else n.error("Hidden fields are not enabled for this survey");return o})(e.hiddenFields,null==n?void 0:n.hiddenFields);await H(e,t,a)},H=async(e,t,n)=>{var s;const a=r.getInstance(),o=I.getInstance(),i=T.getInstance();if(O)return void a.debug("A survey is already running. Skipping.");M(!0),e.delay&&a.debug(`Delaying survey "${e.name}" by ${e.delay.toString()} seconds.`);const{project:d}=o.get().environment.data,{language:c}=o.get().user.data,g=e.languages.length>1;let p="default";if(g){const t=((e,t)=>{const n=e.languages.map((e=>e.language.code));if(!t)return"default";const r=e.languages.find((e=>{var n;return e.language.code===t.toLowerCase()||(null==(n=e.language.alias)?void 0:n.toLowerCase())===t.toLowerCase()}));return(null==r?void 0:r.default)?"default":r&&r.enabled&&n.includes(r.language.code)?r.language.code:void 0})(e,c);if(!t)return a.debug(`Survey "${e.name}" is not available in specified language.`),void M(!1);p=t}const m=e.projectOverwrites??{},f=m.clickOutsideClose??d.clickOutsideClose,v=m.darkOverlay??d.darkOverlay,h=m.placement??d.placement,y=d.inAppSurveyBranding,w=await G(),b=o.get().environment.data.recaptchaSiteKey,k=Boolean(b&&(null==(s=e.recaptcha)?void 0:s.enabled)),U=()=>(async(e,t="submit_response")=>{const n=r.getInstance();if(!e)return n.debug("reCAPTCHA site key not found"),null;try{return await x(e),window.grecaptcha?await new Promise(((n,r)=>{window.grecaptcha.ready((async()=>{try{const r=await window.grecaptcha.execute(e,{action:t});n(r)}catch(s){r(new Error(String(s)))}}))})):(n.debug("reCAPTCHA API not available"),null)}catch(s){const e=s instanceof Error?s.message:"Unknown error";return n.debug(`Error during reCAPTCHA execution: ${e}`),null}})(b);k&&b&&await x(b);const S=setTimeout((()=>{w.renderSurvey({appUrl:o.get().appUrl,environmentId:o.get().environmentId,contactId:o.get().user.data.contactId??void 0,action:t,survey:e,isBrandingEnabled:y,clickOutside:f,darkOverlay:v,languageCode:p,placement:h,styling:l(d,e),hiddenFieldsRecord:n,recaptchaSiteKey:b,isSpamProtectionEnabled:k,getRecaptchaToken:U,onDisplayCreated:()=>{const t=o.get().user.data.displays,n={surveyId:e.id,createdAt:new Date},r=t.length?[...t,n]:[n],s=o.get(),a={...s.user,data:{...s.user.data,displays:r,lastDisplayAt:new Date}},i=u(s.environment,a);o.update({...s,environment:s.environment,user:a,filteredSurveys:i})},onResponseCreated:()=>{const t=o.get().user.data.responses,n={...o.get().user,data:{...o.get().user.data,responses:t.length?[...t,e.id]:[e.id]}},r=u(o.get().environment,n);o.update({...o.get(),environment:o.get().environment,user:n,filteredSurveys:r})},onClose:R,getSetIsResponseSendingFinished:e=>{}})}),1e3*e.delay);t&&i.add(t,S)},R=()=>{const e=I.getInstance();_(),N();const{environment:t,user:n}=e.get(),r=u(t,n);e.update({...e.get(),environment:t,user:n,filteredSurveys:r}),M(!1)},N=()=>{const e=document.createElement("div");e.id=y,document.body.appendChild(e)},_=()=>{var e;null==(e=document.getElementById(y))||e.remove()},G=()=>{const e=I.getInstance();return new Promise(((t,n)=>{if(window.formbricksSurveys)t(window.formbricksSurveys);else{const r=document.createElement("script");r.src=`${e.get().appUrl}/js/surveys.umd.cjs`,r.async=!0,r.onload=()=>{t(window.formbricksSurveys)},r.onerror=e=>{console.error("Failed to load Formbricks Surveys library:",e),n(new Error(`Failed to load Formbricks Surveys library: ${e}`))},document.head.appendChild(r)}}))},B=async(e,t,n)=>{const s=r.getInstance(),a=I.getInstance(),o=t??e;s.debug(`Formbricks: Action "${o}" tracked`);const i=a.get().filteredSurveys;if(Boolean(i)&&i.length>0)for(const r of i)for(const t of r.triggers)t.actionClass.name===e&&await j(r,e,n);else s.debug("No active surveys to display");return{ok:!0,data:void 0}},W=async(e,t)=>{const n=I.getInstance(),{environment:{data:{actionClasses:r=[]}}}=n.get(),s=r.filter((e=>"code"===e.type)).find((t=>t.key===e));return s?B(s.name,e,t):a({code:"invalid_code",message:`${e} action unknown. Please add this action in Formbricks first in order to use it in your code.`})},q=e=>async t=>{const n=await(r=t,B(r));var r;if(!n.ok){const r=n.error,s=r.message??"An unknown error occurred.";console.error(`ðŸ§± Formbricks - Error in no-code ${e} action '${t}': ${s}`,r)}return n},J=q("page view"),Y=q("click"),z=q("exit intent"),K=q("scroll"),V=["hashchange","popstate","pushstate","replacestate","load"];let Q=!1,X=!1;const Z=async()=>{var e;const t=D.getInstance(),n=I.getInstance(),s=r.getInstance(),a=T.getInstance();s.debug(`Checking page url: ${window.location.href}`);const o=n.get().environment.data.actionClasses.filter((e=>{var t;return"noCode"===e.type&&"pageView"===(null==(t=e.noCodeConfig)?void 0:t.type)}));for(const r of o){const n=(null==(e=r.noCodeConfig)?void 0:e.urlFilters)??[];if(m(n))await t.add(J,E.GeneralAction,!0,r.name);else{const e=a.getTimeouts().find((e=>e.event===r.name));e&&(a.remove(e.timeoutId),M(!1))}}return{ok:!0,data:void 0}},ee=()=>{Z()},te=()=>{if("undefined"!=typeof window&&!Q){if(!X){const e=history.pushState;history.pushState=function(...t){e.apply(this,t);const n=new Event("pushstate");window.dispatchEvent(n)},X=!0}V.forEach((e=>{window.addEventListener(e,ee)})),Q=!0}};let ne=!1;const re=e=>{(async e=>{const t=D.getInstance(),n=I.getInstance(),{environment:r}=n.get(),{actionClasses:s=[]}=r.data,a=s.filter((e=>{var t;return"noCode"===e.type&&"click"===(null==(t=e.noCodeConfig)?void 0:t.type)})),o=e.target;for(const i of a)f(o,i)&&await t.add(Y,E.GeneralAction,!0,i.name)})(e)};let se=!1;const ae=e=>{(async e=>{var t;const n=D.getInstance(),r=I.getInstance(),{environment:s}=r.get(),{actionClasses:a=[]}=s.data,o=a.filter((e=>{var t;return"noCode"===e.type&&"exitIntent"===(null==(t=e.noCodeConfig)?void 0:t.type)}));if(e.clientY<=0&&o.length>0)for(const i of o){const e=(null==(t=i.noCodeConfig)?void 0:t.urlFilters)??[];m(e)&&await n.add(z,E.GeneralAction,!0,i.name)}})(e)};let oe=!1,ie=!1;const de=()=>{(async()=>{var e;const t=D.getInstance(),n=I.getInstance(),r=window.scrollY,s=window.innerHeight,a=document.documentElement.scrollHeight;if(0===r&&(ie=!1),!ie&&r/(a-s)>=.5){ie=!0;const{environment:r}=n.get(),{actionClasses:s=[]}=r.data,a=s.filter((e=>{var t;return"noCode"===e.type&&"fiftyPercentScroll"===(null==(t=e.noCodeConfig)?void 0:t.type)}));for(const n of a){const r=(null==(e=n.noCodeConfig)?void 0:e.urlFilters)??[];m(r)&&await t.add(K,E.GeneralAction,!0,n.name)}}})()};let ce=null;const ue={expiresAt:null,data:{userId:null,contactId:null,segments:[],displays:[],responses:[],lastDisplayAt:null}};let le=!1;const ge=()=>{var e;(()=>{const e=I.getInstance(),t=r.getInstance();if("undefined"!=typeof window&&null===L){const n=async()=>{const n=e.get().environment.expiresAt;try{if(n&&new Date(n)>=new Date)return;t.debug("Environment State has expired. Starting sync.");const r=e.get().user,s=await P({appUrl:e.get().appUrl,environmentId:e.get().environmentId});if(!s.ok)throw s.error;{const{data:t}=s,n=u(t,r);e.update({...e.get(),environment:t,filteredSurveys:n})}}catch(r){console.error("Error during expiry check: ",r),t.debug("Extending config and try again later.");const n=e.get();e.update({...n,environment:{...n.environment,expiresAt:new Date((new Date).getTime()+18e5)}})}};L=window.setInterval((()=>{n()}),6e4)}})(),(()=>{const e=I.getInstance();"undefined"!=typeof window&&null===ce&&(ce=setInterval((()=>{e.get().user.data.userId&&e.update({...e.get(),user:{...e.get().user,expiresAt:new Date((new Date).getTime()+18e5)}})}),6e4))})(),te(),"undefined"==typeof window||ne||(document.addEventListener("click",re),ne=!0),"undefined"==typeof document||se||(null==(e=document.querySelector("body"))||e.addEventListener("mouseleave",ae),se=!0),"undefined"==typeof window||oe||("complete"===document.readyState?window.addEventListener("scroll",de):window.addEventListener("load",(()=>{window.addEventListener("scroll",de)})),oe=!0)},pe=()=>{le||(window.addEventListener("beforeunload",(()=>{L&&(clearInterval(L),L=null),ce&&(clearInterval(ce),ce=null),"undefined"!=typeof window&&Q&&(V.forEach((e=>{window.removeEventListener(e,ee)})),Q=!1),ne&&(document.removeEventListener("click",re),ne=!1),se&&(document.removeEventListener("mouseleave",ae),se=!1),oe&&(window.removeEventListener("scroll",de),oe=!1)})),le=!0)},me=async e=>{var t,n;const s=v(),i=r.getInstance();s&&i.configure({logLevel:"debug"});let d=I.getInstance();const{changed:c,newState:l}=(()=>{const e=localStorage.getItem(h);if(e){const t=JSON.parse(e);if(t.environmentState){const{apiHost:e,environmentState:n,personState:r,attributes:s,...a}=t;return{changed:!0,newState:{...a,...e&&{appUrl:e},environment:n,...r&&{user:{...r,data:{...r.data,...(null==s?void 0:s.language)&&{language:s.language}}}}}}}}return{changed:!1}})();if(c&&(d.resetConfig(),d=I.getInstance(),l&&!(null==(n=null==(t=l.user)?void 0:t.data)?void 0:n.userId)&&d.update(l)),o)return i.debug("Already set up, skipping setup."),{ok:!0,data:void 0};let g;try{g=d.get(),i.debug("Found existing configuration.")}catch{i.debug("No existing configuration found.")}if("error"===(null==g?void 0:g.status.value)){if(s)return i.debug("Formbricks is in error state, but debug mode is active. Resetting config and continuing."),d.resetConfig(),{ok:!0,data:void 0};console.error("ðŸ§± Formbricks - Formbricks was set to an error state.");const e=g.status.expiresAt;if(e&&p(new Date(e)))return console.error("ðŸ§± Formbricks - Error state is not expired, skipping initialization"),{ok:!0,data:void 0};console.error("ðŸ§± Formbricks - Error state is expired. Continuing with initialization.")}if(i.debug("Start setup"),!e.environmentId)return i.debug("No environmentId provided"),a({code:"missing_field",field:"environmentId"});if(!e.appUrl)return i.debug("No appUrl provided"),a({code:"missing_field",field:"appUrl"});if(i.debug("Adding widget container to DOM"),N(),(null==g?void 0:g.environment)&&g.environmentId===e.environmentId&&g.appUrl===e.appUrl){i.debug("Configuration fits setup parameters.");let t=!1,n=!1;const r=new Date(g.environment.expiresAt);p(r)&&(i.debug("Environment state expired. Syncing."),t=!0),g.user.expiresAt&&p(new Date(g.user.expiresAt))&&(i.debug("User state expired. Syncing."),n=!0);try{let r=g.environment,o=g.user;if(t||s){s&&i.debug("Debug mode is active, refetching environment state");const t=await P({appUrl:e.appUrl,environmentId:e.environmentId});if(!t.ok)return i.error(`Error fetching environment state: ${t.error.code} - ${t.error.responseMessage??""}`),a({code:"network_error",message:"Error fetching environment state",status:500,url:new URL(`${e.appUrl}/api/v1/client/${e.environmentId}/environment`),responseMessage:t.error.message});r=t.data,i.debug(`Fetched ${r.data.surveys.length.toString()} surveys from the backend`)}if(n||s)if(s&&i.debug("Debug mode is active, refetching user state"),o.data.userId){const t=await S({appUrl:e.appUrl,environmentId:e.environmentId,updates:{userId:o.data.userId}});if(!t.ok)return i.error(`Error updating user state: ${t.error.code} - ${t.error.responseMessage??""}`),a({code:"network_error",message:"Error updating user state",status:500,url:new URL(`${e.appUrl}/api/v1/client/${e.environmentId}/update/contacts/${o.data.userId}`),responseMessage:"Unknown error"});o=t.data.state}else s||(o=ue);const c=u(r,o);d.update({...g,environment:r,user:o,filteredSurveys:c});const l=c.map((e=>e.name));i.debug(`${l.length.toString()} surveys could be shown to current user on trigger: ${l.join(", ")}`)}catch{i.debug("Error during sync. Please try again.")}}else{i.debug("No valid configuration found. Resetting config and creating new one."),d.resetConfig(),i.debug("Syncing.");try{const t=await P({appUrl:e.appUrl,environmentId:e.environmentId});if(!t.ok)throw t.error;let n=ue;if("userId"in e&&e.userId){const t=await S({appUrl:e.appUrl,environmentId:e.environmentId,updates:{userId:e.userId,attributes:e.attributes}});t.ok?n=t.data.state:i.error(`Error updating user state: ${t.error.code} - ${t.error.responseMessage??""}`)}const r=t.data;i.debug(`Fetched ${r.data.surveys.length.toString()} surveys from the backend`);const s=u(r,n);d.update({appUrl:e.appUrl,environmentId:e.environmentId,user:n,environment:r,filteredSurveys:s});const a=s.map((e=>e.name));i.debug(`${a.length.toString()} surveys could be shown to current user on trigger: ${a.join(", ")}`)}catch(m){await fe(m)}}return i.debug("Adding event listeners"),ge(),pe(),o=!0,i.debug("Set up complete"),Z(),{ok:!0,data:void 0}},fe=e=>{const t=r.getInstance();"forbidden"===e.code?t.error(`Authorization error: ${e.responseMessage}`):t.error(`Error during first setup: ${e.code} - ${e.responseMessage}. Please try again later.`);const n={status:{value:"error",expiresAt:new Date((new Date).getTime()+6e5)}};throw d((()=>{localStorage.setItem(h,JSON.stringify(n))}))(),new Error("Could not set up formbricks")},ve=async e=>{const t=A.getInstance();return t.updateAttributes(e),t.processUpdates(),{ok:!0,data:void 0}},he=async e=>{const t=I.getInstance(),n=r.getInstance(),s=A.getInstance(),{data:{userId:o}}=t.get().user;return o?(n.error("A userId is already set in formbricks, please first call the logout function and then set a new userId"),a({code:"forbidden",message:"User already set",responseMessage:"User already set",status:403})):(s.updateUserId(e),s.processUpdates(),{ok:!0,data:void 0})},ye=()=>{try{const e=r.getInstance(),t=I.getInstance(),{userId:n}=t.get().user.data;return n?((()=>{const e=r.getInstance(),t=I.getInstance(),{environment:n}=t.get(),s=u(n,ue);e.debug("Setting user state to default"),t.update({...t.get(),user:ue,filteredSurveys:s}),_(),N(),M(!1)})(),{ok:!0,data:void 0}):(e.error("No userId is set, please use the setUserId function to set a userId first"),{ok:!0,data:void 0})}catch{return{ok:!1,error:new Error("Failed to logout")}}},we=D.getInstance(),be=async e=>{if(e.userId||e.attributes||e.apiHost){v()&&console.warn("ðŸ§± Formbricks - Warning: Using legacy init"),await we.add(me,E.Setup,!1,{...e,...e.apiHost&&{appUrl:e.apiHost}})}else await we.add(me,E.Setup,!1,e);await we.wait()};return{init:e=>be(e),setup:be,setEmail:async e=>{await we.add(ve,E.UserAction,!0,{email:e})},setAttribute:async(e,t)=>{await we.add(ve,E.UserAction,!0,{[e]:t})},setAttributes:async e=>{await we.add(ve,E.UserAction,!0,e)},setLanguage:async e=>{await we.add(ve,E.UserAction,!0,{language:e})},setUserId:async e=>{await we.add(he,E.UserAction,!0,e)},track:async(e,t)=>{await we.add(W,E.GeneralAction,!0,e,t)},logout:async()=>{await we.add(ye,E.GeneralAction)},registerRouteChange:async()=>{await we.add(Z,E.GeneralAction)}}}));
